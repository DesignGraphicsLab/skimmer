<!DOCTYPE html>
<html>
<head>

<meta charset="ISO-8859-1">
<title>Skimmer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>Skimmer</title>
		<script type="text/javascript" src="js/skimmer.js"></script>
		<script type="text/javascript" src="js/stopwords.js"></script>
		<script type="text/javascript" src="lib/jquery/jquery-1.3.2.js"></script>
		<script type="text/javascript" src="js/agent.js"></script>
		<script type="text/javascript" src="js/obj_vet.js"></script>
		<script type="text/javascript" src="js/article.js"></script>
		<script type="text/javascript" src="js/map.js"></script>
		<script type="text/javascript" src="js/stemmer.js"></script>
		<script type="text/javascript" src="js/dictionary.js"></script>
		<script type="text/javascript" src="js/invertedFileSystem.js"></script>
		<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type = "text/javascript">

	//global variable
	var skimmer;
	var canvas;
	var ctx;
	
	var slidercanvas;
	var sliderctx;
	
	var intervalID;

	var feedFinished = 0;		// A flag used to denote the end of feeding and is initially set zero
	var feedResult;				// The result of using google feed API

	var numEntries = 20;		// The number of entries to be obtained in the feed result
	
	// Default RSS source address
	var sourceAddress = "http://calendar.activedatax.com/ncstate/RSSSyndicator.aspx?category=&location=&type=N&binary=Y&keywords=";
	//sourceAddress = "http://api.flickr.com/services/feeds/photos_public.gne?tags=ncsu&lang=en-us&format=rss_200";
	var ratioCanvas = 1;
	var scaleNow = 0;
	var scaleOld = 0;
	var isFlickr = 0; 
	var ind = 0;
	var currentCursor = new Vector2(); //for mouse move
	var simuCursor = new Vector2();    //for automouse
	var desDir = new Vector2();       //automouse main direction
	
	var reachFlag = 1;
	var linkFlag = 0;                  //imagelink
	var showImageFlag = 1;        
	var checkImageUrlFlag = 0; 
	var depthOrder = new Array();   //depth of agents
	var depthChangeCount = 0 ;      
	var DEPTHLAYER = 10;           
	var IMAGE_SWITCH_LIMIT = 50;
	var LEAST_IMAGE_WIDTH = 30;      //less than the value would be regarded as invalid
	var AGENT_REMOVE_LIMIT = 200;     //secondary agents
	var DEPTH_COUNT_LIMIT = 50;      //for soften
	var DEPTH_FREQUENCY = 120;
	var MAX_LINE = 10;               //text box content
	var OVERLAP_DETECTION = 100;     
	var autoFlag = 0;
	var initStep = 5;               //automouse
	var mouseCount = 1;              
	var arrow = new Image();         //arrow for automode
	arrow.src = "data/arrow.png";
	// Define the inverted file system
	//var IFS = new InvertedFileSystem();
	
	
	//for overlaping manipulation
	
	var agentOverlapMark = null;     //detect overlap
	var overlapCheckCount = 0;       
	
	var tAlpha = 0 ;               //tmp
	// Record the title of the skimmer
	var titleRecord = "";


	
	// Read RSS from a website with the help of Google Javascript API Google Feed
	google.load("feeds", "1");
	// Define the callback function
	function initialize() {

		// Reset the feeding flag
		feedFinished = 0;
		
		// Set the URL for the google feed API
		var feed = new google.feeds.Feed(sourceAddress);
		// Set the number of entries to be read from the RSS online
		feed.setNumEntries(numEntries);

		// downloads the feed specified in the constructor from Google's servers and calls the given callback when the download completes
		feed.load(function(result) {
			if (!result.error) {
				feedResult = result;
				canvas = document.getElementById("canvas");
				
				// Initialize the absolute position to zero
				absPosX = 0;
				absPosY = 0;
				
				tempElem = canvas;
				
				while (tempElem.offsetParent != null) {
					absPosX += tempElem.offsetLeft;
					absPosY += tempElem.offsetTop;
					tempElem = tempElem.offsetParent;
				}

				// Finally get the absolute position of the canvas element
				absPosX += tempElem.offsetLeft;
				absPosY += tempElem.offsetTop;


				
				// Build the skimmer and set the attributes for the skimmer
				skimmer = new Skimmer(absPosX, absPosY, canvas.width, canvas.height, feedResult, numEntries);
				
				// Set the title according to requirements
				skimmer.agentTitle.text = "NCSU Events";
				
				skimmer.addNewArticles();
				skimmer.extractArticleMinMax();
				skimmer.checkForAdjacencies();
				skimmer.updateAgents();
				skimmer.extractAgentMinMax();
				buildAgentLinkList();
				var selectObj = document.getElementById("selectColor");
				var selectIndex=selectObj.selectedIndex;
				var selectVal = selectObj.options[selectIndex].value;
				skimmer.colorType = selectVal;
				skimmer.updateAgentColor();

				// Hide the progress bar when feeding is done
			}

			feedFinished = 1;

		});
	}
	google.setOnLoadCallback(initialize);


	// Set the event when a key is pressed
	function keyDown(event){
		 var keyCode = ('which' in event) ? event.which : event.keyCode;
		 
		 /*
		 if(keyCode == 27){
			 if(skimmer.agentArticle != null){
				 skimmer.agentArticle.remove = true;
				 skimmer.selectedWords.length = 0;
				 skimmer.selectedArticles.length = 0;
				 skimmer.selectedArticleRanking.clear();
			 }
			 else if(skimmer.zoomedAgents.length > 0){
				 for(var i = 0 ; i < skimmer.zoomedAgents.length; i++){
					 skimmer.zoomedAgents[i].remove = true;
				 }
				 skimmer.zoomedAgents.length = 0;
			 }
			 else{
				 clearInterval(intervalID);
			 }
		 }else if(keyCode == 49){
			 skimmer.colorType = 0;
			 skimmer.updateAgentColor();
		 }else if(keyCode == 50){
			 skimmer.colorType = 1;
			 skimmer.updateAgentColor();
		 }else if(keyCode == 51){
			 skimmer.colorType = 2;
			 skimmer.updateAgentColor();
		 }else if(keyCode == 52){
			 skimmer.colorType = 3;
			 skimmer.updateAgentColor();
		 }else if(keyCode == 13){
			// Set the action when the "Enter" button is pressed down
			skimmerSearching();
		 }
		 */
		
		
		// When enter the pressed under the advanced mode, advanced searching starts
		if ((keyCode == 13) && (advancedFlag == 0)) {
			AdvancedSearching();
		}
	}
	
	
	var mouseMoveFlag = 0;
	var isControlPanelHide = false;
	var mouseMoveIntervalID;
	
	
	var recordeClientMouseCoorX = 0;
	var recordeClientMouseCoorY = 0;
	
	function mouseMove(event){
	
		//mouseMoveFlag = 0;
		
		if( skimmer != undefined ) {

			currentCursor.set(event.clientX - skimmer.left  + document.documentElement.scrollLeft, event.clientY + document.documentElement.scrollTop - skimmer.top);
			//console.log(currentCursor);
			
			
			// The last position of the cursor is recorded to check mouse move
			// These code are added because of the bug in Chrome browsers
			if ((event.clientX != recordeClientMouseCoorX) && (event.clientY != recordeClientMouseCoorY)) {

				if (isControlPanelHide == true) {
				}

				mouseMoveFlag = 0;

				recordeClientMouseCoorX = event.clientX;
				recordeClientMouseCoorY = event.clientY;
			}
			
		}
		else {
			mouseMoveFlag = 0;
		}
	}
	
	function globalKeyFunc() {
		mouseMoveFlag = 0;
	}
	
	function hideControlPanel(status) {
		if (status == "hide") {
			// Hide the control panel

			var winWidth = getWinWidth();
			var winHeight = getWinHeight();

			table = document.getElementById("overallFrame");
			table.style.display = winWidth*ratioCanvas;
			table.height = winHeight*ratioCanvas;

			tableSel = document.getElementById("selectFrame");
			tableSel.hidden = true;
			
			
			
			tblautoSubFrame = document.getElementById("autoSubFrame");
			tblautoSubFrame.hidden = true;
			
			
			
			canvas = document.getElementById("canvas");
			canvas.width = table.width;
			canvas.height = table.height;
			
			ctx = canvas.getContext("2d");

			// Get the style ratio of the elements on the webpage
			if (canvas.width <= canvas.height) {
				scaleNow = canvas.width;
				scaleOld = 1024;
			}
			else {
				scaleNow = canvas.height;
				scaleOld = 768;
			}
			
			isControlPanelHide = true;
		}
		else {
			// Show the control panel
			var winWidth = getWinWidth();
			var winHeight = getWinHeight();

			table = document.getElementById("overallFrame");
			table.style.display = winWidth*ratioCanvas;
			table.height = winHeight*ratioCanvas;

			tableSel = document.getElementById("selectFrame");
			tableSel.hidden = false;


			tblautoSubFrame = document.getElementById("autoSubFrame");
			tblautoSubFrame.hidden = false;

			
			canvas = document.getElementById("canvas");
			canvas.width = Math.round(table.width * 8.0 / 9);
			canvas.height = table.height;
			
			ctx = canvas.getContext("2d");

			// Get the style ratio of the elements on the webpage
			if (canvas.width <= canvas.height) {
				scaleNow = canvas.width;
				scaleOld = 1024;
			}
			else {
				scaleNow = canvas.height;
				scaleOld = 768;
			}

			isControlPanelHide = false;
			mouseMoveFlag = 0;
		}

		skimmer.width = canvas.width;
		skimmer.height = canvas.height;
		if(skimmer.agentArticle!=null) {
			skimmer.agentArticle.width = skimmer.width / 3 * scaleNow / scaleOld;

			skimmer.agentArticle.height = skimmer.height / 3 * scaleNow / scaleOld;
		}
		
		absPosX = 0;
		absPosY = 0;
		
		tempElem = canvas;
		
		while (tempElem.offsetParent != null) {
			absPosX += tempElem.offsetLeft;
			absPosY += tempElem.offsetTop;
			tempElem = tempElem.offsetParent;
		}
		
		absPosX += tempElem.offsetLeft;
		absPosY += tempElem.offsetTop;
		
		skimmer.left = absPosX;
		skimmer.top = absPosY;

	}

	// Check whether the mouse is moving
	function checkMouseMove() {
		// Count up the time during which the mouse did not move
		if (skimmer != undefined) {
			if ((isControlPanelHide == false)&&(mouseMoveFlag >= 10)) {
				hideControlPanel("hide");
			}
			else if ((isControlPanelHide == true)&&(mouseMoveFlag < 10)) {
				hideControlPanel("show");
			}
			mouseMoveFlag++;
		}
	}
	
	//check whether image url is valid, not use in the code 
	function checkImageUrl(){
	
		for(var i =0 ; i<skimmer.agents.length ; i++){
			var count = skimmer.agents[i].imageLinkList.length;
				var k=0;
				for(var j=0; j<count ; j++){
				var tmp = new Image();
				tmp.src = skimmer.agents[i].imageLinkList[k];
				if(tmp.width>0){k++;}
				else
				{
					skimmer.agents[i].imageLinkList[k]=skimmer.agents[i].imageLinkList[skimmer.agents[i].imageLinkList.length-1];
					skimmer.agents[i].imageLinkList.pop();
				}
				
			}
		
		}
	}
	
	// build up agents image link list
	function buildAgentLinkList(){
		
		for(var i = 0; i < skimmer.agents.length; i++){
			for(var j = 0; j < skimmer.articles.length; j++){
				if(skimmer.articles[j].words.indexOf(skimmer.agents[i].text) > -1 || skimmer.articles[j].titlewords.indexOf(skimmer.agents[i].text)  > -1 ){
					if(skimmer.articles[j].imageUrl != null){
						
						skimmer.agents[i].imageLinkList.push(skimmer.articles[j].imageUrl);
						
					}
				}
			}		
		}
		
		//build up array to store overlap info
		agentOverlapMark = new Array(skimmer.agents.length);
		depthOrder = new Array(skimmer.agents.length);
		overlapCheckCount = 0;
		
		for(var i = 0; i < skimmer.agents.length; i++){
			depthOrder[i]=new Array();
			depthOrder[i][0]=i
			depthOrder[i][1]=Math.floor(DEPTHLAYER*Math.random());
			
			agentOverlapMark[i] = -1;
		}	
	}
	
	//mouse click function
	function mouseClick(event){
		
		
		var cursor = new Vector2();
		if(autoFlag == 0){
			cursor.set(event.clientX - skimmer.left + document.documentElement.scrollLeft - (skimmer.width / 2), event.clientY + document.documentElement.scrollTop - skimmer.top - (skimmer.height / 2 ));
		}
		else
		cursor.set(simuCursor.returnX(),simuCursor.returnY());
		
		//title link
		if(event.button == 0 && linkFlag == 2 && autoFlag == 0 )
		{
			window.open('http://designgraphics.ncsu.edu/search/label/skimmer');
		}
		else if(event.button == 0 && linkFlag == 3 && autoFlag == 0 )
		{
			window.open('http://designgraphics.ncsu.edu');
		}
		
		//triggered if text box appears
		if(skimmer.agentArticle!=null){
			var agentArticleBounds = skimmer.agentArticle.getBoundingBox();
			if(agentArticleBounds.contains(cursor)){
				//change text box mode
				if(event.altKey == true && event.ctrlKey == false ){
						skimmer.agentArticle.shiftMode = 3 - skimmer.agentArticle.shiftMode;
				}
				else{
				var curIndex = skimmer.selectedArticles.indexOf(skimmer.selectedArticle);
				if(curIndex >= 0){
					if(event.button == 0){
						//open link
						if (linkFlag == 1 && autoFlag == 0 )
						{
							window.open(skimmer.agentArticle.source);
						}
						
						else
						{
							curIndex += 1;
						}
					}
					else{
						curIndex -= 1;
					}
					if(curIndex >= skimmer.selectedArticles.length){
						curIndex = 0;
					}
					if(curIndex < 0){
						curIndex = skimmer.selectedArticles.length - 1;
					}
					//turn to next text box
					skimmer.selectedArticle = skimmer.selectedArticles[curIndex];
					skimmer.agentArticle.title = skimmer.selectedArticle.title;
					skimmer.agentArticle.text = skimmer.selectedArticle.summary;
					skimmer.agentArticle.source = skimmer.selectedArticle.source;
					skimmer.agentArticle.imageUrl = skimmer.selectedArticle.imageUrl;
				}
				
				}
			}
			//cancel text box
			else{
				skimmer.agentArticle.remove = true;
				skimmer.selectedWords.length = 0;
				skimmer.selectedArticles.length = 0;
				skimmer.selectedArticleRanking.clear();
			}
		}
		//shift key
		if(event.button == 0 && event.shiftKey == true && event.ctrlKey == false && event.altKey == false && skimmer.agentArticle == null){
			
			skimmer.selectedWords.length = 0;
			skimmer.selectedArticles.length = 0;
			skimmer.selectedArticleRanking.clear();
			
			// Build the selected words list
			var tmpVect = new Vector2();
			var dist;
			for(var i = 0; i < skimmer.agents.length; i++){
				var agent = skimmer.agents[i];
				
				tmpVect.setVect(agent.pos);
				tmpVect.sub(cursor);

				dist = tmp = tmpVect.length();
				if(dist < agent.radius){
					skimmer.selectedWords.push(agent);
				}
			}
			
			// If words were selected, rank articles based on the selected articles
			// Then sort them into a list of the top picks
			// Finally generate the agent
			if(skimmer.selectedWords.length > 0){
				for(var i = 0; i < skimmer.articles.length; i++){
					var article = skimmer.articles[i];
					var rank = 0;
					for(var j = 0; j < skimmer.selectedWords.length; j++){
						var agent = skimmer.selectedWords[j];
						if(article.words.indexOf(agent.stem) > -1){
							rank += 1.0 + (agent.occurrences / skimmer.maxOccurrence);
						}
						if(article.titlewords.indexOf(agent.stem) > -1){
							rank += 2.0;
						}
					}
					skimmer.selectedArticleRanking.put(article,rank);
		
				}
				
				// Build a collection of the top ranked articles
				for(var i = 0; i < skimmer.selectedArticleRanking.valSet().length; i++){
					var article = skimmer.selectedArticleRanking.keySet()[i];
					var rank = skimmer.selectedArticleRanking.valSet()[i];
					
					if(skimmer.selectedArticles.length == 0){
						skimmer.selectedArticles.push(article);
					}
					else{
						for(var j = 0; j < skimmer.selectedArticles.length; j++){
							var curArticle = skimmer.selectedArticles[j];
							var curRank = skimmer.selectedArticleRanking.get(curArticle);
							
							if(rank >= curRank){
								skimmer.selectedArticles = skimmer.selectedArticles.add(article, j);
								break;
							}
							
						}
						if(skimmer.selectedArticles.indexOf(article) < 0){
							skimmer.selectedArticles.push(article);
						}
					}
				}
				
				if(skimmer.selectedArticles.length != 0){
					skimmer.selectedArticle = skimmer.selectedArticles[0];
					
					//alert("scaleNow" + scaleNow +"scaleOld" + scaleOld);
					//if( isFlickr == 1 )
					//skimmer.agentArticle = new AgentArticle(skimmer.width / 3 * scaleNow / scaleOld, skimmer.height / 3 * scaleNow / scaleOld, skimmer.selectedArticle.title, skimmer.selectedArticle.summary, skimmer.selectedArticle.source,convertUrl(skimmer.selectedArticle.imageUrl));
					//else
					skimmer.agentArticle = new AgentArticle(skimmer.width / 3, skimmer.height / 3, skimmer.selectedArticle.title, skimmer.selectedArticle.summary, skimmer.selectedArticle.source,skimmer.selectedArticle.imageUrl);
					//fix color
					//alert(skimmer.width / 3 * scaleNow / scaleOld+"  "+skimmer.height / 3 * scaleNow / scaleOld)
					skimmer.agentArticle.pos.setVect(cursor);
				}
				
			}
			
			
			
			//var showNews = document.getElementById("NewsDetail");
			//showNews.appendChild(document.createTextNode(skimmer.selectedArticles[0].rsscontent));

			
		}
		else if(event.button == 0 && event.shiftKey == false && event.ctrlKey == true && event.altKey == false && skimmer.agentArticle==null){
			var clickedAgent = skimmer.getAgentClickedAt(cursor);
			//console.log(cursor.toString());
			if(clickedAgent != null && clickedAgent.clickPriority == 1){
				// Build a collection of the top ranked words for entry
				var newWords = new Array();
				var clickedWord = clickedAgent.stem;
				
				for(var i = 0; i < skimmer.words.length; i++){
					var word = skimmer.words[i];
					var alreadyAnAgent = false;
					for(var j = 0; j < skimmer.agents.length; j++){
						var agent = skimmer.agents[j];
						if(word.toLowerCase() == agent.stem.toLowerCase()){
							alreadyAnAgent = true;
							break;
						}
					}
					if(!alreadyAnAgent){
						var pair = skimmer.getPair(clickedWord, word);
						var cooccurrence = skimmer.cooccurrences.get(pair);
						var cfidf = cooccurrence / skimmer.occurrences.get(word);
						
						if(newWords.length == 0){
							newWords.push(word);
						}
						else if(newWords.length < skimmer.MAX_WORDS_PER_ZOOM){
							for(var j = 0; j < newWords.length; j++){
								var curWord = newWords[j];
								var curPair = skimmer.getPair(clickedWord, curWord);
								var curCooccurrence = skimmer.cooccurrences.get(curPair);
								var curCfidf = curCooccurrence / skimmer.occurrences.get(curWord);
								
								if(cfidf >= curCfidf){
									newWords = newWords.add(word, j);
									break;
								}
								
							}
							if(newWords.indexOf(word) < 0){
								newWords.add(word);
							}
						}
						else{
							var lastWord = newWords[newWords.length - 1];
							var lastPair = skimmer.getPair(clickedWord, lastWord);
							var lastCooccurrence = skimmer.cooccurrences.get(lastPair);
							var lastCfidf = lastCooccurrence / skimmer.occurrences.get(lastWord);
							
							if(cfidf > lastCfidf){
								newWords.pop();
								for(var j = 0; j < newWords.length; j++){
									var curWord = newWords[j];
									var curPair = skimmer.getPair(clickedWord, curWord);
									var curCooccurrence = skimmer.cooccurrences.get(curPair);
									var curCfidf = curCooccurrence / skimmer.occurrences.get(curWord);
									
									if(cfidf >= curCfidf){
										newWords = newWords.add(word, j);
										break;
									}
								}
								if(newWords.indexOf(word) < 0){
									newWords.push(word);
								}
							}
						}
					}
				}
				
				var tmpAgent;
				for(var i = 0; i < newWords.length; i++){
					var word = newWords[i];
					if(skimmer.zoomedAgents.length > skimmer.MAX_ZOOMED_AGENTS){
						skimmer.zoomedAgents.shift().remove = true;
					}
					tmpAgent = new AgentWord();
					
					tmpAgent.stem = word;
					tmpAgent.text = skimmer.stems.get(word);
					tmpAgent.occurrences = skimmer.occurrences.get(word);
					tmpAgent.pos.set(cursor.x - 3.0 + Math.random() * 6.0, cursor.y - 3.0 + Math.random() * 6.0);
					tmpAgent.avgPos.setVect(tmpAgent.pos);
					tmpAgent.timestamp = new Date();
					tmpAgent.desiredAlpha = 1.0;
					tmpAgent.textColor = skimmer.colorAgentWordText;
					
					//mark tmpagent to secondary class with limit function
					tmpAgent.clickPriority = 2;
					skimmer.agents.push(tmpAgent);
					skimmer.zoomedAgents.push(tmpAgent);
				}
				skimmer.updateAgentColor();
				
			}
			//build new image source list
			buildAgentLinkList();
		}
		else if(event.button == 0 && event.shiftKey == true && event.ctrlKey == true && event.altKey == true && skimmer.agentArticle==null){
			
			var clickedAgent = skimmer.getAgentClickedAt(cursor);
			if(clickedAgent != null){
				var curIndex = skimmer.agents.indexOf(clickedAgent);
				skimmer.agents[curIndex].remove = true;
			}
		}
	}
	
	function autoMouse(){
		
		desDir.setVect(skimmer.agents[ind].avgPos);
		var tmpV = new Vector2();
		
		tmpV.setVect(simuCursor);
		tmpV.sub(desDir);
		tmpV.negate();
		tmpV.normalizePara(initStep * scaleNow / scaleOld);
		
		//last position of auto curse 
		//var tmpX=simuCursor.returnX(); 
		//var tmpY=simuCursor.returnY();
		
		simuCursor.add(tmpV);
		//simuCursor.set(simuCursor.returnX()+lastSimuMotion.returnX(), simuCursor.returnY()+lastSimuMotion.returnY());
		
		//prevent cursor from exceeding bound
		//if(Math.abs(simuCursor.returnX())>=1.0 / 3 *skimmer.width || Math.abs(simuCursor.returnY())>=1.0 / 3 *skimmer.height )

				//simuCursor.set(tmpX,tmpY);
		
			
		//move possibility
		
		
		
		if (  simuCursor.dist(desDir) <  1.5* initStep * scaleNow / scaleOld){	
		//create new mouse event
		ind = Math.floor(Math.random()*(skimmer.agents.length-1));
		
		desDir.setVect(skimmer.agents[ind].avgPos);
		
			
		var autoEvent = document.createEvent("MouseEvents");
		//event.initMouseEvent(type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, 
        //ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget);
  		if(Math.random() < 0.5){;}
  		
  		else if(Math.random() < 0.2){
  			autoEvent.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, true, true, true, false, 0, null);
			mouseClick(autoEvent);
		}
		else if(Math.random() < 0.5){
			autoEvent.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, true, false, false, false, 0, null);
			mouseClick(autoEvent);
		}
		else{
			autoEvent.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, true, false, 0, null);
			mouseClick(autoEvent);
		}
		}
		
	}
	
	//real draw image function
	function drawAvoidStretch(agent,ctx, img, color,dx, dy, dw, dh){
		
		var minLength = img.width>img.height?img.height:img.width;
		
		
		var stretchFactor = 0.5;
		if (minLength <= LEAST_IMAGE_WIDTH)
		{
		}
		else if ( minLength * 1.0 / stretchFactor >  dw *0.75 )   
		//center
		{
			ctx.save();
			ctx.beginPath();
			//clip function
			ctx.arc(dx+dw*0.5,dy+dh*0.5,dw*0.5,0,2*Math.PI,true);
			ctx.closePath();
			ctx.clip();
			
			//cut a square region of image
			if(img.width>img.height){
				ctx.drawImage(img,0.5*(img.width-img.height),0,img.height,img.height, dx, dy, dw, dh);
			}
			else{
				ctx.drawImage(img,0, 0.5*(img.height-img.width),img.width,img.width, dx, dy, dw, dh);
			}
			if(skimmer.selectedWords.length != 0 && (skimmer.selectedWords.indexOf(agent) < 0 ))
			{
			ctx.fillStyle= 'rgba(100,100,100,0.5)';
			ctx.fillRect(dx,dy,dw,dh);
			}
			ctx.restore();
		}
		else       
		//fade with color
		{
			//var x=ctx.globalAlpha;
			
			ctx.save();
			//ctx.globalAlpha = x;
			ctx.beginPath();
			ctx.arc(dx+dw*0.5,dy+dh*0.5,minLength/ stretchFactor*0.5, 0,Math.PI*2,true);
			//ctx.arc(dx+dw*0.5,dy+dh*0.5,dw, 0,Math.PI*2,true);
			ctx.closePath();
			ctx.clip();
			
			if(img.width>img.height){
				ctx.drawImage(img,0.5*(img.width-img.height),0,img.height,img.height,dx+dw*0.5-minLength*0.5 / stretchFactor,dy+dh*0.5-minLength*0.5/ stretchFactor,minLength/ stretchFactor,minLength/ stretchFactor );
			}
			else{
				ctx.drawImage(img,0, 0.5*(img.height-img.width),img.width,img.width,dx+dw*0.5-minLength*0.5/ stretchFactor,dy+dh*0.5-minLength*0.5/ stretchFactor,minLength/ stretchFactor,minLength/ stretchFactor);
			}
			if(skimmer.selectedWords.length != 0 && (skimmer.selectedWords.indexOf(agent) < 0 ))
			{
			ctx.fillStyle= 'rgba(100,100,100,0.5)';
			ctx.fillRect(dx,dy,dw,dh);
			}
			
			ctx.restore();
			
			
			//create gradient to look good
			ctx.save();
			ctx.beginPath();
			ctx.arc(dx+dw*0.5,dy+dh*0.5,dw*0.5,0,2*Math.PI,true);
			ctx.closePath();
			ctx.clip();
			var radgrad = ctx.createRadialGradient(dx+dw*0.5,dy+dh*0.5,minLength/stretchFactor*0.5*0.7,dx+dw*0.5,dy+dh*0.5,dw);
			var tmpAlpha = color.alpha;
			color.alpha = 0;
			radgrad.addColorStop(0,color);
			color.alpha = 1;
			radgrad.addColorStop((minLength/stretchFactor*0.5*0.3/(dw-minLength/stretchFactor*0.5*0.7)),color);
			ctx.fillStyle = radgrad;
			ctx.fillRect(dx,dy,dw,dh);
			color.alpha = tmpAlpha;
			ctx.restore();
			
			
			
		} 
		
	}
	


	
	// Set the attributes for the bar
	var barHeightRatio = 0;
	var barHeight = 0;
	var barWidth = 0;
	
	// Set the attributes for the dragger
	var draggerWidth = 0;
	var draggerMargin = 0;
	var draggerHeight = 0;

	// The value from the slider bar
	// Initially set to the center
	var valueSlider = 50;

	// A flag denote the pressed down status of the dragger
	var DraggerDown = 0;
	
	// On the event that the mouse is pressed and check whether the dragger is picked
	function SliderMouseDown(event) {

		// Get the absolute coordinates of the mouse click event
		var e = slidercanvas;
		var AbsX = e.offsetLeft;
		var AbsY = e.offsetTop;
		
		while(e=e.offsetParent)
		{
			AbsX += e.offsetLeft;
			AbsY += e.offsetTop;
	    }
		
		//alert("PX: " + AbsX + "PY" + AbsY);
		//alert("X: " + event.clientX + "Y: " + event.clientY);

		// Get the related x and y
		var cursorX = event.clientX - AbsX + document.documentElement.scrollLeft;
		var cursorY = event.clientY - AbsY + document.documentElement.scrollTop;

		//var d = (valueSlider / 100 * slidercanvas.width + 1 / 2 * draggerWidth);
		//console.log("Mouse " + cursorX + " Dragger " + d + " W " + draggerWidth);
		
		if (Math.abs(cursorX - (valueSlider / 100 * slidercanvas.width - 1 / 2 * draggerWidth)) <= 1 / 2 * draggerWidth) {
			DraggerDown = 1;
		}
	}


	// On the event that the mouse is moved
	function SliderMouseMove(event) {

		if (DraggerDown == 1) {
			// Get the absolute coordinates of the mouse click event
			var e = slidercanvas;
			var AbsX = e.offsetLeft;
			var AbsY = e.offsetTop;
			
			while(e=e.offsetParent)
			{
				AbsX += e.offsetLeft;
				AbsY += e.offsetTop;
		    }
			
			//alert("PX: " + AbsX + "PY" + AbsY);
			//alert("X: " + event.clientX + "Y: " + event.clientY);
			
			// Get the related x and y
			//var cursorX = event.clientX - AbsX;
			//var cursorY = event.clientY - AbsY;
			var cursorX = event.clientX - AbsX + document.documentElement.scrollLeft;
			var cursorY = event.clientY - AbsY + document.documentElement.scrollTop;
			
			if (slidercanvas.width > 0) {
				if (cursorX <= draggerWidth) {
					valueSlider = 0
				}
				else if (cursorX >= slidercanvas.width - draggerWidth) {
					valueSlider = 100
				}
				else {
					valueSlider = (cursorX - draggerWidth) / (slidercanvas.width - 2 * draggerWidth) * 100;
				}
				//alert(valueSlider);
			}
		}
	}

	
	// On the event that the mouse is released
	function SliderMouseUp(event) {

		// Get the absolute coordinates of the mouse click event
		var e = slidercanvas;
		var AbsX = e.offsetLeft;
		var AbsY = e.offsetTop;
		
		while(e=e.offsetParent)
		{
			AbsX += e.offsetLeft;
			AbsY += e.offsetTop;
	    }
		
		//alert("PX: " + AbsX + "PY" + AbsY);
		//alert("X: " + event.clientX + "Y: " + event.clientY);
		
		// Get the related x and y
		//var cursorX = event.clientX - AbsX;
		//var cursorY = event.clientY - AbsY;
		var cursorX = event.clientX - AbsX + document.documentElement.scrollLeft;
		var cursorY = event.clientY - AbsY + document.documentElement.scrollTop;

		
		if (slidercanvas.width > 0) {
			if (cursorX <= draggerWidth) {
				valueSlider = 0
			}
			else if (cursorX >= slidercanvas.width - draggerWidth) {
				valueSlider = 100
			}
			else {
				valueSlider = (cursorX - draggerWidth) / (slidercanvas.width - 2 * draggerWidth) * 100;
			}
			//alert(valueSlider);
		}
		
		DraggerDown = 0;
	}
	
	
	// The global mouse up function
	function mouseUp(event) {
		DraggerDown = 0;

		//alert(valueSlider);
	}
	
	
	// Draw the slider bar to control the image and text
	function drawSliderBar() {
		// Draw the slider bar
		if(sliderctx == undefined ) return;
		sliderctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
		sliderctx.fillRect(0,0,slidercanvas.width,slidercanvas.height);
		
		// Set the size of the bar
		barHeightRatio = 1 / 3;
		//var barWidthMargin = slidercanvas.width * 1 / 20;
		
		barHeight = slidercanvas.height * barHeightRatio;
		barWidth  = slidercanvas.width;

		// Set the size of the dragger
		draggerWidth = barWidth * 1 / 10;
		draggerMargin = slidercanvas.height * 1 / 10;
		draggerHeight = slidercanvas.height - 2 * draggerMargin;
		
		// Set the margin for the bar
		barWidth = barWidth - 2 * draggerWidth;
		
		// Draw the bar
		sliderctx.fillStyle = 'rgba(100, 100, 100, 1.0)';
		sliderctx.fillRect(draggerWidth / 2, slidercanvas.height * 1 / 3, barWidth, barHeight);

		// Draw the dragger
		sliderctx.fillStyle = 'rgba(200, 200, 200, 1.0)';
		sliderctx.fillRect((valueSlider / 100) * barWidth, draggerMargin,  draggerWidth, draggerHeight);
	}
	
	
	
	// Added as the driver of the draw funcion
	function drawDriver(){

		//drawSliderBar();

		if (feedFinished == 1) {
			draw();
		}
		else {
			drawDialog();
		}
	}
	
	
	function drawDialog() {

		if(canvas == undefined ) return;
		// Set the origin of the canvas
		var origin = new Vector2();
		origin.set(canvas.width/2, canvas.height/2);
		
		// Fill the background
		ctx.fillStyle = 'rgba(0,0,0,1.0)';
		ctx.fillRect(0,0,canvas.width,canvas.height);
		
		// To scale the drawing result according to the screen
		scaleNow = 0;		// The scale for the rescaled screen
		scaleOld = 0;		// The scale for the 1024 * 768 screen
		if (canvas.width <= canvas.height) {
			scaleNow = canvas.width;
			scaleOld = 1024;
		}
		else {
			scaleNow = canvas.height;
			scaleOld = 768;
		}
		
		// Set the starting point and the size of the color key box
		var OffSet = 30;
		var DialogX = canvas.width * 1 / 3;
		var DialogY = canvas.height * 3 / 7;
		var DialogWidth  = canvas.width * 1 / 3;
		var DialogHeight = canvas.height * 1 / 7;


		// Draw the dialog out
		ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
		//ctx.fillRect(DialogX, DialogY, DialogWidth, DialogHeight);
		
		
		
		ctx.font = 'bold '+Math.round(30 * scaleNow / scaleOld)+'px Arial';
		ctx.textAlign = "center";
		ctx.textBaseline = "top";
		ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
		ctx.fillText("Loading data...", DialogX + DialogWidth / 2, DialogY + DialogHeight / 2 - 30 / 2 * scaleNow / scaleOld);

		
		
		ctx.font = 'bold italic '+Math.round(30 * scaleNow / scaleOld)+'px Arial';
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		ctx.fillText("Skimmer, by Design Graphics Lab", canvas.width / 2, canvas.height - 20 *scaleNow / scaleOld);  //bottom
		//alert(canvas.height);

	}
	
	
	
	function checkAgentOverlap(){
		
		for(var i=0;i<agentOverlapMark.length; i++)
			agentOverlapMark[i] = -1;
			
		//gogo
		if(skimmer == undefined || skimmer.agents.length <= 0 ) return ;
		
		var clusterCount = 0;
		
		for(var i=0; i < skimmer.agents.length ; i++ ){
			
			for(var j=i+1; j < skimmer.agents.length; j++){
				
				//distance detect
				if(skimmer.agents[i].avgPos.dist(skimmer.agents[j].avgPos) <  skimmer.agents[j].radius+skimmer.agents[i].radius ){
				
					var iLink, jLink;
					//get current image url of agents
					if(skimmer.agents[i].pictureMode == 0)
						continue;
					else if(skimmer.agents[i].pictureMode == 2)
					iLink = skimmer.agents[i].imageLinkList[skimmer.agents[i].imageIndex];
					else if(skimmer.agents[i].pictureMode == 1)
					iLink = skimmer.agents[i].validImage.src;
				
					if(skimmer.agents[j].pictureMode == 0)
						continue;
					else if(skimmer.agents[j].pictureMode == 2)
					jLink = skimmer.agents[j].imageLinkList[skimmer.agents[j].imageIndex];
					else if(skimmer.agents[j].pictureMode == 1)
					jLink = skimmer.agents[j].validImage.src;
						
						if(iLink == jLink && iLink != null && iLink != "" && iLink != " "){
						//console.log(skimmer.agents[i].text+" "+skimmer.agents[j].text);
						
						//mark agents with cluster count
						if( agentOverlapMark[j] != -1){
							if(agentOverlapMark[i] == -1)	
							agentOverlapMark[i] = agentOverlapMark[j];
							
							else if(agentOverlapMark[i] != agentOverlapMark[j]){
								var tt = agentOverlapMark[i];
								for(var jj = 0; jj<agentOverlapMark.length; jj++){
									if(agentOverlapMark[jj] == tt )
										agentOverlapMark[jj] = agentOverlapMark[j];
									}
									
						          clusterCount--;
							}
						}
						else if(agentOverlapMark[i] != -1)
							agentOverlapMark[j] = agentOverlapMark[i];
						
						else
							agentOverlapMark[j]=agentOverlapMark[i]=clusterCount++;
						}
				}
			}
				
				
		}
		
		
		var cFlag = new Array(clusterCount);
		for(var i =0;i<cFlag.length; i++)
			cFlag[i]=0;
		
		//random assign alpha
		if(depthOrder.length != skimmer.agents.length){
		
			for(var i = 0; i <skimmer.agents.length ; i++){
				//console.log(skimmer.agents[i].text+" "+agentOverlapMark[i]);
				if( agentOverlapMark[i] > -1 && cFlag[agentOverlapMark[i]] == 0 ){
					cFlag[agentOverlapMark[i]] = 1;
					agentOverlapMark[i] = 1;
				}
				else if(agentOverlapMark[i] > -1 && cFlag[agentOverlapMark[i]] == 1){
					agentOverlapMark[i] = 0;
				}
				else
					agentOverlapMark[i] = -1;
			}
		
			}
		
		else{
					//let the closest to get alpha 1 and fade others
					for(var i=depthOrder.length-1; i > -1 ; i--){
						
						var tmpIndex = depthOrder[i][0];  
						var tmpEntry = depthOrder[i][1];
						
					if( agentOverlapMark[tmpIndex] > -1 && cFlag[agentOverlapMark[tmpIndex]] == 0 ){ 
							cFlag[agentOverlapMark[tmpIndex]] = 1;
							agentOverlapMark[tmpIndex] = 1;
					}
					else if(agentOverlapMark[tmpIndex] > -1 && cFlag[agentOverlapMark[tmpIndex]] == 1){
						agentOverlapMark[tmpIndex] = 0;
					}	
					else
						agentOverlapMark[tmpIndex] = -1;
					
					}
			
		
		
			}
		
	}
	
	function drawText(ctx,agent,origin){
			
			
			var alpha = parseFloat( (  agent.TICKS_TILL_FADE - agent.curTicksTillFade ) / agent.TICKS_TILL_FADE ) ;
			if( alpha > 1.0 ) { alpha = 1.0; }
			if( alpha < 0.0 ) { alpha = 0.0; }
			ctx.fillStyle = agent.textColor.toString();
			ctx.textBaseline = 'middle';
			ctx.textAlign = 'center';
			
			//different font for different class of agents
			if(agent.clickPriority == 1){
				ctx.font = 'bold ' + Math.round(16 * scaleNow / scaleOld) + 'px Arial';
			}
			else{
				ctx.font = 'italic bold ' + Math.round(16 * scaleNow / scaleOld) + 'px Arial';
			}
			
			metrics = ctx.measureText(agent.text);
			agent.bounds.extents.set( metrics.width / 2.0 +5 , 10 );
			if(skimmer.selectedWords.length != 0 && (skimmer.selectedWords.indexOf(agent) < 0 )){
				var colorUnselected = agent.textColor.darker().darker();
				ctx.fillStyle = colorUnselected.toString();
			}		

			//back ground color of text for agents with image
			if (agent.imageLinkList[0] !=null && showImageFlag == 1 && agent.imageLinkValidation == 1 && skimmer.selectedWords.indexOf(agent) < 0 )	{

				ctx.save();
				ctx.beginPath();
				ctx.arc(Math.round(origin.x + agent.avgPos.x), Math.round(origin.y + agent.avgPos.y),Math.round(agent.radius)-1,0,Math.PI*2,true);
				ctx.closePath();
				ctx.clip();

				ctx.fillStyle = 'rgba(50,50,50,0.8)';
				var agentBounds = agent.getBoundingBox();		
				
				tAlpha = ctx.globalAlpha;
				ctx.globalAlpha *=( valueSlider <= 50 )? (valueSlider / 50.0 ): ((100 - valueSlider) / 50.0); 

				ctx.fillRect(Math.round(origin.x + agent.avgPos.x - agentBounds.extents.x),
						Math.round(origin.y + agent.avgPos.y - agentBounds.extents.y * scaleNow / scaleOld),
						Math.round(agentBounds.extents.x * 2),
						Math.round(agentBounds.extents.y * 2* scaleNow / scaleOld));
				ctx.globalAlpha = tAlpha;
				ctx.restore();	

			}

			
			
			ctx.fillStyle='rgba(250,250,250,0.8)';
			
			tAlpha = ctx.globalAlpha ; 
			ctx.globalAlpha = ( agent.pictureMode == 0 )? (valueSlider > 50 ? valueSlider / 100.0 : 0.5) : valueSlider / 100.0;
			
			//render text
			if(metrics.width < agent.radius*2)
			ctx.fillText(agent.text.toLowerCase(), Math.round(origin.x + agent.avgPos.x), Math.round(origin.y + agent.avgPos.y));
			else{
			ctx.fillText(agent.text.slice(0,Math.round(agent.text.length*(agent.radius*2.0/metrics.width))).toLowerCase(), Math.round(origin.x + agent.avgPos.x), Math.round(origin.y + agent.avgPos.y));
		
			}
			ctx.globalAlpha = tAlpha;
			
		
	}
	
	
	
	
	function draw(){

		// Set the global attributes of the canvas
		// These lines of code should always be placed first
		var origin = new Vector2();
		//console.log(autoFlag);
		origin.set(skimmer.width/2, skimmer.height/2);
		ctx.fillStyle = 'rgba(0,0,0,1.0)';
		ctx.fillRect(0,0,skimmer.width,skimmer.height);

		// To scale the drawing result according to the screen
		scaleNow = 0;		// The scale for the rescaled screen
		scaleOld = 0;		// The scale for the 1024 * 768 screen
		if (skimmer.width <= skimmer.height) {
			scaleNow = skimmer.width;
			scaleOld = 1024;
		}
		else {
			scaleNow = skimmer.height;
			scaleOld = 768;
		}

		// The color key box of the canvas

		// Set the starting point and the size of the color key box
		var OffSet = 30;
		var ColorKeyStartX = skimmer.width - 200 * scaleNow / scaleOld - OffSet * scaleNow / scaleOld;
		var ColorKeyStartY = skimmer.height - 200 * scaleNow / scaleOld - OffSet * scaleNow / scaleOld;
		var ColorKeyWidth  = 180 * scaleNow / scaleOld;
		var ColorKeyHeight = 180 * scaleNow / scaleOld;

		// Set the border width of the color key box
		var Border = 4;


		// To confirm the existance of the skimmer object
		if (skimmer != undefined) {
			// Show the color key according to the color mapping scheme
			switch (skimmer.colorType) {
				case "0":
				case 0:
					// random
					// There is no color key for a random color mapping scheme
					/*
					// Draw the box and the border
					ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
					ctx.fillRect(ColorKeyStartX, ColorKeyStartY, ColorKeyWidth, ColorKeyHeight);
					ctx.fillStyle = 'rgba(150, 150, 150, 0.6)';
					ctx.fillRect(ColorKeyStartX + Border, ColorKeyStartY + Border, ColorKeyWidth - 2 * Border, ColorKeyHeight - 2 * Border);

					ctx.font = 'bold '+Math.round(16 * scaleNow / scaleOld)+'px Arial';
					ctx.textAlign = "left";
					ctx.textBaseline = "top";
					ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
					ctx.fillText("RANDOM", ColorKeyStartX + Border + 3, ColorKeyStartY + ColorKeyHeight / 2 - 16 * scaleNow / scaleOld);
					 */
					break;
				case "1":
				case 1:
					// grammar
					// Draw the box and the border
					// The box is removed
					/*
					ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
					ctx.fillRect(ColorKeyStartX, ColorKeyStartY, ColorKeyWidth, ColorKeyHeight);
					ctx.fillStyle = 'rgba(150, 150, 150, 0.6)';
					ctx.fillRect(ColorKeyStartX + Border, ColorKeyStartY + Border, ColorKeyWidth - 2 * Border, ColorKeyHeight - 2 * Border);
					*/

					// ADJECTIVE
					ctx.font = 'bold '+Math.round(16 * scaleNow / scaleOld)+'px Arial';
					//ctx.textAlign = "center";
					//ctx.textBaseline = "top";
					ctx.fillStyle = 'rgba(0, 0, 100, 1.0)';
					ctx.fillText("ADJECTIVE", ColorKeyStartX + ColorKeyWidth / 2, ColorKeyStartY + ColorKeyHeight * 1 / 6 - 4 * scaleNow / scaleOld);

					// VERB
					//ctx.font = 'bold '+Math.round(16 * scaleNow / scaleOld)+'px Arial';
					//ctx.textAlign = "center";
					//ctx.textBaseline = "top";
					ctx.fillStyle = 'rgba(0, 100, 0, 1.0)';
					ctx.fillText("VERB", ColorKeyStartX + ColorKeyWidth / 2, ColorKeyStartY + ColorKeyHeight * 2 / 6 - 4 * scaleNow / scaleOld);

					// ADVERB
					//ctx.font = 'bold '+Math.round(16 * scaleNow / scaleOld)+'px Arial';
					//ctx.textAlign = "center";
					//ctx.textBaseline = "top";
					ctx.fillStyle = 'rgba(100, 100, 0, 1.0)';
					ctx.fillText("ADVERB", ColorKeyStartX + ColorKeyWidth / 2, ColorKeyStartY + ColorKeyHeight * 3 / 6 - 4 * scaleNow / scaleOld);

					// INTERJECTION
					//ctx.font = 'bold '+Math.round(16 * scaleNow / scaleOld)+'px Arial';
					//ctx.textAlign = "center";
					//ctx.textBaseline = "top";
					ctx.fillStyle = 'rgba(100, 0, 0, 1.0)';
					ctx.fillText("INTERJECTION", ColorKeyStartX + ColorKeyWidth / 2, ColorKeyStartY + ColorKeyHeight * 4 / 6 - 4 * scaleNow / scaleOld);

					// NOUN
					//ctx.font = 'bold '+Math.round(16 * scaleNow / scaleOld)+'px Arial';
					//ctx.textAlign = "center";
					//ctx.textBaseline = "top";
					ctx.fillStyle = 'rgba(100, 0, 100, 1.0)';
					ctx.fillText("NOUN", ColorKeyStartX + ColorKeyWidth / 2, ColorKeyStartY + ColorKeyHeight * 5 / 6 - 4 * scaleNow / scaleOld);

					break;
				case "3":
				case 3:
					// emotioin
					// Draw the box and the border
					// The box is removed
					/*
					ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
					ctx.fillRect(ColorKeyStartX, ColorKeyStartY, ColorKeyWidth, ColorKeyHeight);
					ctx.fillStyle = 'rgba(150, 150, 150, 0.6)';
					ctx.fillRect(ColorKeyStartX + Border, ColorKeyStartY + Border, ColorKeyWidth - 2 * Border, ColorKeyHeight - 2 * Border);
					*/


					// Set the boundings of the gradient area
					var GradientOffset = 36 * scaleNow / scaleOld
					var GradientX = ColorKeyStartX + Border + GradientOffset / 2;
					var GradientY = ColorKeyStartY + Border + GradientOffset;
					var GradientWidth  = ColorKeyWidth - GradientOffset - 2 * Border;
					var GradientHeight = ColorKeyHeight - 2 * GradientOffset - 2 * Border;

					// Draw the gradient color key
					var colorkey_gradient = ctx.createLinearGradient(GradientX, GradientY, GradientX, GradientY + GradientHeight);
					colorkey_gradient.addColorStop(0, 'rgba(255, 255, 0, 1)');
					colorkey_gradient.addColorStop(1, 'rgba(0, 0, 255, 1)');
					ctx.fillStyle = colorkey_gradient;
					ctx.fillRect(GradientX, GradientY, GradientWidth, GradientHeight);

					// Draw the intensive
					colorkey_gradient = ctx.createLinearGradient(GradientX, GradientY, GradientX + GradientWidth, GradientY);
					colorkey_gradient.addColorStop(0, 'rgba(50, 50, 50, 1)');
					colorkey_gradient.addColorStop(1, 'rgba(50, 50, 50, 0)');
					ctx.fillStyle = colorkey_gradient;
					ctx.fillRect(GradientX, GradientY, GradientWidth, GradientHeight);

					// HAPPY
					ctx.font = 'bold '+Math.round(16 * scaleNow / scaleOld)+'px Arial';
					ctx.textAlign = "center";
					ctx.textBaseline = "top";
					ctx.fillStyle = 'rgba(255, 255, 0, 1.0)';
					ctx.fillText("HAPPY", ColorKeyStartX + ColorKeyWidth / 2, ColorKeyStartY + 16 * scaleNow / scaleOld);

					// SAD
					ctx.font = 'bold '+Math.round(16 * scaleNow / scaleOld)+'px Arial';
					ctx.textAlign = "center";
					ctx.textBaseline = "top";
					ctx.fillStyle = 'rgba(0, 0, 255, 1.0)';
					ctx.fillText("SAD", ColorKeyStartX + ColorKeyWidth / 2 , ColorKeyStartY + ColorKeyHeight * 13 / 16);

					
					// LOW
					ctx.font = 'bold '+Math.round(16 * scaleNow / scaleOld)+'px Arial';
					ctx.textAlign = "center";
					ctx.textBaseline = "top";
					ctx.fillStyle = 'rgba(50, 50, 50, 1.0)';
					ctx.fillText("LOW", ColorKeyStartX, ColorKeyStartY + ColorKeyHeight / 2);

					// HIGH
					ctx.font = 'bold '+Math.round(16 * scaleNow / scaleOld)+'px Arial';
					ctx.textAlign = "center";
					ctx.textBaseline = "top";
					ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
					ctx.fillText("HIGH", ColorKeyStartX + ColorKeyWidth, ColorKeyStartY + ColorKeyHeight / 2);

					break;

				default: 
					break;
			}
		}
		//BOTTOM TITLE
		
		var skimmerTextWidth = ctx.measureText("Skimmer, by Design Graphics Lab").width;

		ctx.fillStyle = "#fff";
		if( origin.x + skimmer.agentTitle.pos.x - skimmerTextWidth / 2.0 < currentCursor.x && currentCursor.x < origin.x + skimmer.agentTitle.pos.x + skimmerTextWidth / 2.0 )
		{

			if	( skimmer.height - 2*20 * scaleNow / scaleOld < currentCursor.y && currentCursor.y < skimmer.height - 20 * scaleNow / scaleOld )
			{
				
				ctx.fillStyle = "#333";
				//open link
				if(origin.x + skimmer.agentTitle.pos.x - skimmerTextWidth / 6.0 < currentCursor.x )
					linkFlag = 3;
				else
					linkFlag = 2;
			}
			else{linkFlag = 0;}
		}	
		else{linkFlag = 0;}
		
		ctx.font = 'bold italic '+Math.round(30 * scaleNow / scaleOld)+'px Arial';
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		
		ctx.fillText("Skimmer, by Design Graphics Lab", origin.x + skimmer.agentTitle.pos.x, skimmer.height - 20 * scaleNow / scaleOld);  //bottom
		////////////////////////////////////////////
		
		
		// Draw the circles. //
		if( skimmer.DRAW_CIRCLES ) {

		
		
				
		
			//assign depth value and sort the depth
			if(depthOrder.length != 0 && depthOrder.length == skimmer.agents.length ){
				
				depthOrder.sort(function(a,b) {return a[1]-b[1]});
				
				if( depthChangeCount > 10000 ) depthChangeCount = 0 ;

				//depth change frequency
				if( ++depthChangeCount%DEPTH_FREQUENCY == 0 ){
				//	depthOrder.sort(function(a,b) {return a[1]-b[1]});
				//}
				
					for(var i=0;i<depthOrder.length;i++){ 
						//inc depth
						
						if( agentOverlapMark[depthOrder[i][0]] == -1)
						depthOrder[i][1]++;
						
						if(depthOrder[i][1] >= DEPTHLAYER ){
						//go from top to bottom
						skimmer.agents[depthOrder[i][0]].switchDepthEnable = 1;
						
						}
					
					}
				}
			}
			else{/*alert(depthOrder.length);*/}
			
			for(var pi = 0; pi < skimmer.agents.length; pi++){
				
				//if(skimmer.agents[pi].localAlpha !=  1 ) 
				   //alert(skimmer.agents[pi].localAlpha);
				
				if(skimmer.agents[pi].switchDepthEnable == 1){
					
					
					skimmer.agents[pi].switchDepthCount++;
					//change alpha to simulate fade 
					skimmer.agents[pi].localAlpha = Math.cos( skimmer.agents[pi].switchDepthCount *1.0 / DEPTH_COUNT_LIMIT *Math.PI - 0.5*Math.PI ) *(-0.7) + 1;
			    	
			    if(skimmer.agents[pi].switchDepthCount == Math.round(DEPTH_COUNT_LIMIT*0.5)){
			    
			    	for(var ki=0;ki<depthOrder.length;ki++){
			    		if ( depthOrder[ki][0] == pi ){
			    			 depthOrder[ki][1] = 0;
			    			 //alert(skimmer.agents[pi].text);
			    			 break;
			    		}
			    	}	
			    	
					//render in new order	
			    }
				
			    //fade process finished
			    if(skimmer.agents[pi].switchDepthCount > DEPTH_COUNT_LIMIT){
			    	skimmer.agents[pi].switchDepthEnable = 0;
			    	skimmer.agents[pi].localAlpha = 1;
			    	skimmer.agents[pi].switchDepthCount = 0;
			    	}
			    }
			}
			
			//change depth if words are clustered with same image url
			for(var pi = 0; pi < skimmer.agents.length; pi++){
				if(agentOverlapMark[pi] == 1){
					skimmer.agents[pi].localAlpha = 1;
				}
				else if(agentOverlapMark[pi] == 0){
					skimmer.agents[pi].localAlpha = 0.5;
				}
			}
			
			


			for(var pi = 0; pi < skimmer.agents.length; pi++){
				if(depthOrder.length != 0 &&  depthOrder.length == skimmer.agents.length)
					//render with depth order
					i = depthOrder[pi][0];
				else
					i = pi;
					
				var agent = skimmer.agents[i];

				var alpha = parseFloat( 0.75 * ( parseFloat( agent.TICKS_TILL_FADE - agent.curTicksTillFade ) / agent.TICKS_TILL_FADE ) );
				if( alpha > 1.0 ) { alpha = 1.0; }
				if( alpha < 0.0 ) { alpha = 0.0; }
				skimmer.agents[i].shapeColor.alpha = alpha;
				ctx.fillStyle = agent.shapeColor.toString();
				if(skimmer.selectedWords.length != 0 && (skimmer.selectedWords.indexOf(agent) < 0 )){
					var colorUnselected = agent.shapeColor.darker();
					ctx.fillStyle = colorUnselected.toString();
				}
				//radius are twice the real radius of agents
				var radius = parseInt(Math.round( ( skimmer.minRadius + ( agent.occurrences /  skimmer.maxOccurrence )
								* ( skimmer.minRadius ) ) * 2.0 * scaleNow / scaleOld));

				// updates the radius value
				tAlpha = ctx.globalAlpha;
				//ctx.globalAlpha = valueSlider > 60 ? (valueSlider/100.0) : agent.localAlpha*(valueSlider/100.0);
				
				//slider control
				ctx.globalAlpha = agent.localAlpha*(valueSlider/100.0);
				if(ctx.globalAlpha <0.1) ctx.globalAlpha = 0.1; 
				skimmer.agents[i].radius = radius / 2;
				ctx.beginPath();
				//render agents circle
				ctx.arc(Math.round(origin.x + agent.avgPos.x), Math.round(origin.y + agent.avgPos.y),Math.round(radius / 2)-2, 0, Math.PI * 2, false); 
				ctx.fill();  
				ctx.closePath();  
				ctx.globalAlpha = tAlpha;


				//render image with switch smoothing
				if (skimmer.agents[i].imageLinkList[0] !=null && showImageFlag == 1 )	{
					var imgNews = new Image();
					tAlpha = ctx.globalAlpha ;
					//slider control
					var ttAlpha = ( 100 - valueSlider ) /100.0;
					
					try{
						if(skimmer.agents[i].imageFrequency>1000) skimmer.agents[i].imageFrequency=1;

						if(++skimmer.agents[i].imageFrequency%400 == 0 && Math.random() < 0.8 || skimmer.agents[i].switchPicture > 0){
							
							//common state without fading
							if(skimmer.agents[i].switchPicture == 0){

								imgNews.src = skimmer.agents[i].imageLinkList[skimmer.agents[i].imageIndex];
								
								//at least one valid image to use
								if(skimmer.agents[i].validImageFlag == 1 && imgNews.width > LEAST_IMAGE_WIDTH )
								{
									skimmer.agents[i].validImageFlag = 0; 
									skimmer.agents[i].validImage = new Image();
									skimmer.agents[i].validImage.src = imgNews.src;
								}

								ctx.globalAlpha = agent.localAlpha*ttAlpha;
								
								//use current url for image
								if ( imgNews.width > LEAST_IMAGE_WIDTH ){
									//ctx.drawImage(imgNews,Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									drawAvoidStretch(agent,ctx,imgNews,agent.shapeColor,Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									agent.pictureMode = 2;
									
								}
								//use valid image because current url is invalid
								else if (skimmer.agents[i].validImageFlag == 0){
									//ctx.drawImage(skimmer.agents[i].validImage, Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									drawAvoidStretch(agent,ctx,skimmer.agents[i].validImage,agent.shapeColor, Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									agent.pictureMode = 1;
								}
								skimmer.agents[i].switchPicture ++;
							}
							
							//smoothing 
							else if(skimmer.agents[i].switchPicture < IMAGE_SWITCH_LIMIT ){

								//ctx.fillStyle = "#000";
								//ctx.arc(Math.round(origin.x + agent.avgPos.x), Math.round(origin.y + agent.avgPos.y),Math.round(radius / 2), 0, Math.PI * 2, false); 

								//blending two pictures with interpolation of alpha
								var inc = (skimmer.agents[i].imageIndex+1)%skimmer.agents[i].imageLinkList.length;
								var fflag = 0;
								ctx.globalAlpha =( 1 - skimmer.agents[i].switchPicture * 1.0/ IMAGE_SWITCH_LIMIT )*agent.localAlpha*ttAlpha;
								
								imgNews.src = skimmer.agents[i].imageLinkList[skimmer.agents[i].imageIndex];
                                
								if ( imgNews.width > LEAST_IMAGE_WIDTH ){
									//ctx.drawImage(imgNews,Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									drawAvoidStretch(agent,ctx,imgNews,agent.shapeColor,Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									agent.pictureMode = 2;
								}
								else if (skimmer.agents[i].validImageFlag == 0){
									//ctx.drawImage(skimmer.agents[i].validImage, Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									drawAvoidStretch(agent,ctx,skimmer.agents[i].validImage, agent.shapeColor,Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									agent.pictureMode = 1;
									fflag++;
								}

								ctx.globalAlpha = (skimmer.agents[i].switchPicture/ IMAGE_SWITCH_LIMIT)*agent.localAlpha*ttAlpha;
								var newImg = new Image();
								newImg.src = skimmer.agents[i].imageLinkList[inc];


								if ( newImg.width > LEAST_IMAGE_WIDTH ){
									//ctx.drawImage(newImg,Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									drawAvoidStretch(agent,ctx,newImg,agent.shapeColor,Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									agent.pictureMode = 2;
								}
								else if (skimmer.agents[i].validImageFlag == 0){
									//ctx.drawImage(skimmer.agents[i].validImage, Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									drawAvoidStretch(agent,ctx,skimmer.agents[i].validImage,agent.shapeColor, Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									agent.pictureMode = 1;
									fflag++;
								}

								skimmer.agents[i].switchPicture ++;
								//ctx.globalAlpha = 1 ;
								ctx.globalAlpha = agent.localAlpha*ttAlpha;
								
								
								newImg=null;
							}
							
							//end fading
							else{
								skimmer.agents[i].switchPicture = 0 ;	
								//url update
								skimmer.agents[i].imageIndex = (skimmer.agents[i].imageIndex+1)%skimmer.agents[i].imageLinkList.length;
								imgNews.src = skimmer.agents[i].imageLinkList[skimmer.agents[i].imageIndex];

								ctx.globalAlpha = agent.localAlpha*ttAlpha;
								if ( imgNews.width > LEAST_IMAGE_WIDTH ){
									//ctx.drawImage(imgNews,Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									drawAvoidStretch(agent,ctx,imgNews,agent.shapeColor,Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									agent.pictureMode = 2;
								}
								else if (skimmer.agents[i].validImageFlag == 0){
									//ctx.drawImage(skimmer.agents[i].validImage, Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									drawAvoidStretch(agent,ctx,skimmer.agents[i].validImage,agent.shapeColor,Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
									agent.pictureMode = 1;
								}
								

							}
						}

						else{

							imgNews.src = skimmer.agents[i].imageLinkList[skimmer.agents[i].imageIndex];
							ctx.globalAlpha = agent.localAlpha*ttAlpha;
							if ( imgNews.width > LEAST_IMAGE_WIDTH ){
								//ctx.drawImage(imgNews,Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
								drawAvoidStretch(agent,ctx,imgNews,agent.shapeColor,Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
								agent.pictureMode = 2;
							}
							
							else if (skimmer.agents[i].validImageFlag == 0){
								//ctx.drawImage(skimmer.agents[i].validImage, Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
								drawAvoidStretch(agent,ctx,skimmer.agents[i].validImage,agent.shapeColor,Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
								agent.pictureMode = 1;
							}
							
						}


						if(imgNews.width > 0 || skimmer.agents[i].validImageFlag == 0 ){
							//ctx.drawImage(imgNews,Math.round(origin.x + agent.avgPos.x-radius / 2 ), Math.round(origin.y + agent.avgPos.y-radius / 2),radius,radius);
							skimmer.agents[i].imageLinkValidation = 1;
						}

						else
							skimmer.agents[i].imageLinkValidation = 0;

						

					}
					//wrong image url
					catch(e){
						skimmer.agents[i].imageLinkValidation = 0;
						console.log(imgNews.src);


					}
					ctx.globalAlpha = tAlpha;
					imgNews=null;

				}
				//ctx.restore();
				drawText(ctx,agent,origin);
				
				
				
			}
		}

		// Draw outline boxes for selected agents. //
		for(var i = 0; i < skimmer.agents.length; i++){
			var agent = skimmer.agents[i];
			var alpha = parseFloat(parseFloat(agent.TICKS_TILL_FADE - agent.curTicksTillFade) / agent.TICKS_TILL_FADE);
			if( alpha > 1.0 ) { alpha = 1.0; }
			if( alpha < 0.0 ) { alpha = 0.0; }
			if(skimmer.selectedWords.indexOf(agent) > -1){
				ctx.fillStyle = agent.shapeColor.toString();
				var agentBounds = agent.getBoundingBox();
				
				ctx.save();
				ctx.beginPath();
				ctx.arc(Math.round(origin.x + agent.avgPos.x), Math.round(origin.y + agent.avgPos.y),Math.round(agent.radius)-1,0,Math.PI*2,true);
				ctx.closePath();
				ctx.clip();
				
				tAlpha = ctx.globalAlpha;
				ctx.globalAlpha *=( valueSlider <= 50 )? (valueSlider / 50.0 ): ((100 - valueSlider) / 50.0); 
				ctx.fillRect(Math.round(origin.x + agent.avgPos.x - agentBounds.extents.x),
						Math.round(origin.y + agent.avgPos.y - agentBounds.extents.y * scaleNow / scaleOld),
						Math.round(agentBounds.extents.x * 2),
						Math.round(agentBounds.extents.y * 2* scaleNow / scaleOld));
				ctx.globalAlpha = tAlpha;
				ctx.restore();
			
			}
		}

		
		
		// Draw all of the text and set the agent's bounding box. //
		/*
		for(var pi = 0; pi < skimmer.agents.length; pi++){
				if(depthOrder.length != 0 &&  depthOrder.length == skimmer.agents.length)
					//render with depth order
					i = depthOrder[pi][0];
				else
					i = pi;
		
			var agent = skimmer.agents[i];
			var alpha = parseFloat( (  agent.TICKS_TILL_FADE - agent.curTicksTillFade ) / agent.TICKS_TILL_FADE ) ;
			if( alpha > 1.0 ) { alpha = 1.0; }
			if( alpha < 0.0 ) { alpha = 0.0; }
			ctx.fillStyle = agent.textColor.toString();
			ctx.textBaseline = 'middle';
			ctx.textAlign = 'center';
			
			//different font for different class of agents
			if(agent.clickPriority == 1){
				ctx.font = 'bold ' + Math.round(16 * scaleNow / scaleOld) + 'px Arial';
			}
			else{
				ctx.font = 'italic bold ' + Math.round(16 * scaleNow / scaleOld) + 'px Arial';
			}
			
			metrics = ctx.measureText(agent.text);
			skimmer.agents[i].bounds.extents.set( metrics.width / 2.0 +5 , 10 );
			if(skimmer.selectedWords.length != 0 && (skimmer.selectedWords.indexOf(agent) < 0 )){
				var colorUnselected = agent.textColor.darker().darker();
				ctx.fillStyle = colorUnselected.toString();
			}		

			//back ground color of text for agents with image
			if (agent.imageLinkList[0] !=null && showImageFlag == 1 && agent.imageLinkValidation == 1 && skimmer.selectedWords.indexOf(agent) < 0 )	{

				ctx.save();
				ctx.beginPath();
				ctx.arc(Math.round(origin.x + agent.avgPos.x), Math.round(origin.y + agent.avgPos.y),Math.round(agent.radius)-1,0,Math.PI*2,true);
				ctx.closePath();
				ctx.clip();

				ctx.fillStyle = 'rgba(50,50,50,0.8)';
				var agentBounds = agent.getBoundingBox();		
				
				tAlpha = ctx.globalAlpha;
				ctx.globalAlpha *=( valueSlider <= 50 )? (valueSlider / 50.0 ): ((100 - valueSlider) / 50.0); 

				ctx.fillRect(Math.round(origin.x + agent.avgPos.x - agentBounds.extents.x),
						Math.round(origin.y + agent.avgPos.y - agentBounds.extents.y * scaleNow / scaleOld),
						Math.round(agentBounds.extents.x * 2),
						Math.round(agentBounds.extents.y * 2* scaleNow / scaleOld));
				ctx.globalAlpha = tAlpha;
				ctx.restore();	

			}

			
			
			ctx.fillStyle='rgba(250,250,250,0.8)';
			
			tAlpha = ctx.globalAlpha ; 
			ctx.globalAlpha = ( agent.pictureMode == 0 )? (valueSlider > 50 ? valueSlider / 100.0 : 0.5) : valueSlider / 100.0;
			
			//render text
			if(metrics.width < agent.radius*2)
			ctx.fillText(agent.text.toLowerCase(), Math.round(origin.x + agent.avgPos.x), Math.round(origin.y + agent.avgPos.y));
			else{
			ctx.fillText(agent.text.slice(0,Math.round(agent.text.length*(agent.radius*2.0/metrics.width))).toLowerCase(), Math.round(origin.x + agent.avgPos.x), Math.round(origin.y + agent.avgPos.y));
		
			}
			ctx.globalAlpha = tAlpha;
			
		}
		*/

		// Draw the title agent if it exists. //
		if( skimmer.agentTitle != null ) {
			ctx.fillStyle = 'rgba(150,150,150,0.6)';
			ctx.textBaseline = 'middle';
			ctx.textAlign = 'center';
			ctx.font = 'bold ' + Math.round(30 * scaleNow / scaleOld) + 'px Arial';

			//gradientPaint
			ctx.beginPath();
			//ctx.fillRect(origin.x + skimmer.agentTitle.pos.x - (skimmer.agentTitle.text.length * 8 + 8) *  scaleNow / scaleOld, 0, (skimmer.agentTitle.text.length * 16 + 16) * scaleNow / scaleOld, 40 * scaleNow / scaleOld);
			ctx.fillStyle = 'rgba(255,255,255,255.8)';
			ctx.fillText(skimmer.agentTitle.text, origin.x + skimmer.agentTitle.pos.x, 20 * scaleNow / scaleOld); //top

		}

		//draw text box
		ctx.save();
		ctx.globalAlpha = 1;
			
		if(skimmer.agentArticle != null){
			
			//clip link string to fit the width of text box
			var displayedTitle = "";
			ctx.font = 'bold '+Math.round(16* scaleNow / scaleOld)+'px Arial';

			var droppedChars = false;
			for(var i = 0; i < skimmer.agentArticle.title.length; i++){
				if(ctx.measureText(displayedTitle).width > skimmer.agentArticle.width * 0.75 ){
					droppedChars = true;
					break;
				}	
				displayedTitle += skimmer.agentArticle.title.charAt(i);
			}
			if(droppedChars){
				displayedTitle += "...";
			}
			//clip link string to fit the width of text box
			ctx.font = 'bold '+Math.round(16* scaleNow / scaleOld)+'px Arial';
			var displayedSource = "";

			var droppedChars1 = false;
			for(var i = 0; i < skimmer.agentArticle.source.length; i++){
				if(ctx.measureText(displayedSource).width > skimmer.agentArticle.width * 0.75 ){
					droppedChars1 = true;
					break;
				}
				displayedSource += skimmer.agentArticle.source.charAt(i);
			}
			if(droppedChars1){
				displayedSource += "...";
			}

			// Reset Max Height to original height
			skimmer.agentArticle.height = skimmer.agentArticle.originalHeight;

			// Extract the lines from the body text and match vertical height to this property
			if(skimmer.agentArticle.text != ""){
				// Extract meaningful measurements and adjust vertical height if necessary

				var requiredTextHeight = 20 * scaleNow / scaleOld;

				//deal with text
				var dealString = "";
				if(skimmer.agentArticle.shiftMode == 1)
				dealString = skimmer.agentArticle.title;
				else
				dealString = skimmer.agentArticle.text;
				
				//cut the content to lines and display
				var dealWords = dealString.split(" ");
				var dealedLines = new Array();
				var j = 0;
				dealedLines.push(new String(""));
				ctx.font = 'bold ' + Math.round(16*scaleNow / scaleOld)+'px Arial';
				dealedLines[0] += dealWords[0];
				var textWidth = 0;
				var lineWidth = 0;
				for(var i = 1; i < dealWords.length; i++){

					if(ctx.measureText(dealedLines[j] + " " + dealWords[i]).width <= (skimmer.agentArticle.width * 0.9 )){

						dealedLines[j] += " ";
						dealedLines[j] += dealWords[i];
					}
					else{
						if(ctx.measureText(dealedLines[j]).width > textWidth){
							textWidth = ctx.measureText(dealedLines[j]).width;
						}
						//single words like url 
						if(ctx.measureText(dealWords[i]).width > (skimmer.agentArticle.width * 0.9 ) )
						{
							dealWords[i] = dealWords[i].substring(0, parseInt(dealWords.length*skimmer.agentArticle.width * 0.9 / ctx.measureText(dealWords[i]).width ));
							
						}
						dealedLines.push(new String(""));
						j += 1;
						dealedLines[j] += dealWords[i];
					}
				}
				if(ctx.measureText(dealedLines[j]).width > textWidth){
					textWidth = ctx.measureText(dealedLines[j]).width;
				}

				// Font height
				requiredTextHeight += (dealedLines.length>MAX_LINE?MAX_LINE:dealedLines.length)* 16 *scaleNow / scaleOld;
				ctx.font = 'bold 16px Arial';
				var titleWidth = ctx.measureText(displayedTitle).width;
				var titleHeight = 20*scaleNow/scaleOld+10;

				ctx.font = 'bold 16px Arial';
				var sourceWidth = ctx.measureText(skimmer.agentArticle.source).width;
				var sourceHeight = 20*scaleNow/scaleOld+10;

			
				skimmer.agentArticle.height = requiredTextHeight + titleHeight + sourceHeight;
				
				
				var titleOffsetY = parseInt(Math.round(20 * 1.75));
				var sourceOffsetY;

				var textBackgroundHeight = skimmer.agentArticle.height - titleHeight - sourceHeight;
				//alert("titleHeight"+titleHeight+"sourceHeight"+sourceHeight+"skimmer.agentArticle.height"+skimmer.agentArticle.height);

				var titleOrigin = new Vector2();
				titleOrigin.set(origin.x + skimmer.agentArticle.pos.x - skimmer.agentArticle.width / 2.0,
						origin.y + skimmer.agentArticle.pos.y - skimmer.agentArticle.height / 2.0);
				var textOrigin = new Vector2();
				textOrigin.set(titleOrigin.x, titleOrigin.y + titleHeight);
				var sourceOrigin = new Vector2();
				sourceOrigin.set(textOrigin.x, textOrigin.y + textBackgroundHeight);

				ctx.lineWidth = "1";
				ctx.fillStyle = 'rgba(140,140,140,0.9)';
				ctx.strokeStyle = 'rgba(200,200,200,0.9)';
				//render outline box
				if(skimmer.agentArticle.shiftMode == 2){
					ctx.fillRect(titleOrigin.x, titleOrigin.y, skimmer.agentArticle.width, titleHeight);
					ctx.strokeRect(titleOrigin.x, titleOrigin.y, skimmer.agentArticle.width, titleHeight);

					ctx.fillRect(sourceOrigin.x, sourceOrigin.y, skimmer.agentArticle.width, sourceHeight);	
					ctx.strokeRect(sourceOrigin.x, sourceOrigin.y, skimmer.agentArticle.width, sourceHeight);
				}
				
				ctx.strokeStyle = 'rgba(255,255,255,0.9)';
				ctx.strokeRect(textOrigin.x, textOrigin.y, skimmer.agentArticle.width, textBackgroundHeight);
				ctx.fillStyle = 'rgba(240,240,240,0.9)';
				ctx.fillRect(textOrigin.x, textOrigin.y, skimmer.agentArticle.width, textBackgroundHeight);

				////////////////////////////////////////////////////////////////////////////////////
				ctx.font = 'bold '+Math.round(16* scaleNow / scaleOld)+'px Arial';
				ctx.textAlign = "left";
				ctx.textBaseline = "top";
				ctx.fillStyle = 'rgba(50,50,50,0.9)';
				var lineOrigin = textOrigin.y + 10* scaleNow / scaleOld;
				for(var i = 0; i < dealedLines.length; i++){
					//no more then max number of lines 
					if(i >= MAX_LINE)
					break;
					//render content
					ctx.fillText(dealedLines[i],textOrigin.x + Math.round(skimmer.agentArticle.width * 0.05), lineOrigin);
		
					lineOrigin += 15* scaleNow / scaleOld;

				}

				if(skimmer.agentArticle.shiftMode == 2){
				ctx.textAlign = "left";
				ctx.textBaseline = "middle";
				ctx.font = 'bold '+Math.round(16* scaleNow / scaleOld)+'px Arial';
				//render title
				ctx.fillText( displayedTitle, textOrigin.x + Math.round(skimmer.agentArticle.width * 0.05), titleOrigin.y+0.5*titleHeight );
				
				ctx.font = 'bold '+Math.round(16* scaleNow / scaleOld)+'px Arial';
				
				if( sourceOrigin.x < currentCursor.x && currentCursor.x < sourceOrigin.x + skimmer.agentArticle.width )
				{
					if	( sourceOrigin.y < currentCursor.y && currentCursor.y < sourceOrigin.y + sourceHeight )
					{
						ctx.fillStyle = "#33f";
						linkFlag = 1;
					}
					else{linkFlag = 0;}
				}	
				else{linkFlag = 0;}
					//render link
					ctx.fillText( displayedSource, textOrigin.x + Math.round(skimmer.agentArticle.width * 0.05), sourceOrigin.y+0.5*sourceHeight );
				
				}
				
				if(skimmer.agentArticle.shiftMode == 1)
					skimmer.agentArticle.bounds.extents.set(skimmer.agentArticle.width / 2 , skimmer.agentArticle.height / 2 );					
				else
					skimmer.agentArticle.bounds.extents.set(skimmer.agentArticle.width / 2 , skimmer.agentArticle.height / 2 );
			}
			else{
				skimmer.agentArticle.remove = true;
				skimmer.selectedWords.length = 0;
				skimmer.selectedArticles.length = 0;
				skimmer.selectedArticleRanking.clear();
			}
		}
		ctx.restore();
		
		//for secondary agents, deal with when it will disappear 
		for(var i = 0; i < skimmer.agents.length; i++){
	
			if(skimmer.agentArticle != null) break;
		
			if(skimmer.agents[i].clickPriority == 2 && skimmer.agents[i].removeCount > AGENT_REMOVE_LIMIT && Math.random() < 0.1 ){
				var curIndex = skimmer.agents.indexOf(skimmer.agents[i]);
				skimmer.agents[curIndex].remove = true;
			}
			else if(skimmer.agents[i].clickPriority == 2){
				skimmer.agents[i].removeCount++;
			}
		
		}
		
		
		if(skimmer.DRAW_CIRCLES && autoFlag == 1){
			autoMouse();
			ctx.fillStyle = 'rgba(255,0,0,0.7)';
			ctx.beginPath();
			
			ctx.drawImage(arrow,Math.round(origin.x+simuCursor.returnX()),Math.round(origin.y+simuCursor.returnY()),20* scaleNow / scaleOld ,20* scaleNow / scaleOld );
			ctx.fill();
			ctx.closePath();
		}
		
		//overlap frequency
		if(overlapCheckCount >= 10000) overlapCheckCount = 600;
		
		if( ++overlapCheckCount % 210 == 0 && overlapCheckCount > 600 ){ checkAgentOverlap();}
	
		skimmer.update(0.05, 1024.0, 768.0, scaleNow , scaleOld);

	}	

		
	
	// This function is used to get the canvas filling the screen when the size of the screen is changed
	
	// The function used to searching the internet and get the result from the Search API
	// The result here is got from the Google news because this website will provide me with RSS data source
	function AddNewData() {
		isFlickr = 0;
		
		// Reset the feeding flag
		//feedFinished = 0;
		
		// Construct the news search address with the help of the google news api
		// THe Source address of the RSS source is kept untouched because when we are to update the RSS feed, there is no need for us to change the RSS source
		
		// Set the URL for the google feed API
		var feed = new google.feeds.Feed(sourceAddress);
		// Set the number of entries to be read from the RSS online
		feed.setNumEntries(numEntries);

		// downloads the feed specified in the constructor from Google's servers and calls the given callback when the download completes
		feed.load(function(result) {
			if (!result.error) {
				feedResult = result;
				
				skimmer.UpdateUsingRssSource(feedResult, 10);


				skimmer.addNewArticles();
				skimmer.extractArticleMinMax();
				skimmer.checkForAdjacencies();
				skimmer.updateAgentsAdd();
				skimmer.extractAgentMinMax();
				buildAgentLinkList();

			}

			//feedFinished = 1;

		});

		google.setOnLoadCallback(initialize);
				
	}
	
	
	// Get the width of the windows
	function getWinWidth(){
		if(window.innerWidth) {
		winWidth=window.innerWidth;
	}
	else if((document.body)&&(document.body.clientWidth)) {
		winWidth=document.body.clientWidth;
	}
		return winWidth;
	}
	
	// Get the height of the windows
	function getWinHeight(){
		if(window.innerHeight) {
			winHeight=window.innerHeight;
		}
		else if((document.body)&&(document.body.clientHeight)) {
			winHeight=document.body.clientHeight;
		}
		return winHeight;
	}
	
	
	function init(){
		
		var winWidth = getWinWidth();
		var winHeight = getWinHeight();

		table = document.getElementById("overallFrame");
		table.width = winWidth*ratioCanvas;
		table.height = winHeight*ratioCanvas;

		//table.width = 7000;
		//table.height = 2000;

			
		tableSel = document.getElementById("selectFrame");
		tableSel.width = Math.round(table.width * 1.0 / 9);
		tableSel.height = table.height * 9 / 10;


		tableAutoSubFrame = document.getElementById("autoSubFrame");
		tableAutoSubFrame.width = Math.round(table.width * 1.0 / 9);
		tableAutoSubFrame.height = table.height * 1 / 10;

		
		canvas = document.getElementById("canvas");
		canvas.width = Math.round(table.width * 8.0 / 9);
		canvas.height = table.height;
		
		ctx = canvas.getContext("2d");

		
		// Get the style ratio of the elements on the webpage
		if (canvas.width <= canvas.height) {
			scaleNow = canvas.width;
			scaleOld = 1024;
		}
		else {
			scaleNow = canvas.height;
			scaleOld = 768;
		}
		
		
		// The ratio of the logo
		var heightRatioLogo = 1.0 / 4;
		// The ratio of text input
		var heightRatioText = 1.0 / 30;
		// The ratio of buttons
		var heightRatioButton = 1.0 / 20;
		// The ratio of font size
		var heightRatioFont = 1.0 / 40;
		
		

		// Add the slider bar for image and text control
		slidercanvas = document.getElementById("slidercanvas");
		slidercanvas.width = tableSel.width;
		slidercanvas.height = tableSel.height * heightRatioText;
		sliderctx = slidercanvas .getContext("2d");;


		// Adjust the blank between two sets of elements
		tableSel.style.fontSize = Math.round(tableSel.height * heightRatioFont) + "px";
				
		// Adjust the blank between two sets of elements
		tableAutoSubFrame.style.fontSize = Math.round(tableSel.height * heightRatioFont) + "px";

		
		// The logo of the project as well as the DGL
		//skimmerLogo = document.getElementById("skimmerLogo");
		//skimmerLogo.style.width = tableSel.height * heightRatioLogo + "px";
		
		//skimmerLogo = document.getElementById("DGLLogo");
		//skimmerLogo.style.width = tableSel.height * heightRatioLogo + "px";
		
		selectColor = document.getElementById("selectColor");
		selectColor.style.width = tableSel.width+"px";
		selectColor.style.height = Math.round(tableSel.height * heightRatioText)+"px";
		selectColor.style.fontSize = Math.round(tableSel.height * heightRatioFont) + "px";
	
		
		chooseSource = document.getElementById("chooseSource");
		chooseSource.style.width = tableSel.width+"px";	
		chooseSource.style.height = Math.round(tableSel.height * heightRatioText)+"px";
		chooseSource.style.fontSize = Math.round(tableSel.height * heightRatioFont) + "px";


		/*
		academicSearching = document.getElementById("skimmerSearching");
		academicSearching.style.width = tableSel.width+"px";	
		academicSearching.style.height = Math.round(tableSel.height * heightRatioButton)+"px";
		academicSearching.style.fontSize = Math.round(tableSel.height * heightRatioFont) + "px";
		*/

		/*
		autoMode = document.getElementById("autoMode");
		autoMode.style.width = tableSel.width+"px";
		autoMode.style.height = Math.round(tableSel.height * heightRatioButton)+"px";
		autoMode.style.fontSize = Math.round(tableSel.height * heightRatioFont) + "px";
		*/

		searchContent = document.getElementById("searchContent");
		searchContent.style.width = tableSel.width+"px";
		searchContent.style.height = Math.round(tableSel.height * heightRatioText)+"px";
		searchContent.style.fontSize = Math.round(tableSel.height * heightRatioFont) + "px";

		
		/*
		chooseEngine = document.getElementById("chooseEngine");
		chooseEngine.style.width = tableSel.width+"px";	
		chooseEngine.style.height = Math.round(tableSel.height * heightRatioText)+"px";
		chooseEngine.style.fontSize = Math.round(tableSel.height * heightRatioFont) + "px";
		*/
		
		
		/*
		advancedSearching = document.getElementById("advancedSearching");
		advancedSearching.style.width = tableSel.width+"px";
		advancedSearching.style.height = Math.round(tableSel.height * heightRatioButton)+"px";
		advancedSearching.style.fontSize = Math.round(tableSel.height * heightRatioFont) + "px";
		*/

		/*
		AdvancedSearchBtn = document.getElementById("AdvancedSearchBtn");
		AdvancedSearchBtn.style.width = tableSel.width+"px";
		AdvancedSearchBtn.style.height = Math.round(tableSel.height * heightRatioButton)+"px";
		AdvancedSearchBtn.style.fontSize = Math.round(tableSel.height * heightRatioFont) + "px";
		*/
		
	}

	// The function to be operated when the window is resized
	function resizeWindow() {
		init();
		if(skimmer != undefined ){
		skimmer.width = canvas.width;
		skimmer.height = canvas.height;
		if(skimmer.agentArticle!=null) {
			skimmer.agentArticle.width = skimmer.width / 3 * scaleNow / scaleOld;
			skimmer.agentArticle.height = skimmer.height / 3 * scaleNow / scaleOld;
		}
		
		/*
		absPosX = 0;
		absPosY = 0;
		
		tempElem = canvas;
		
		while (tempElem.offsetParent != null) {
			absPosX += tempElem.offsetLeft;
			absPosY += tempElem.offsetTop;
			tempElem = tempElem.offsetParent;
		}
		
		absPosX += tempElem.offsetLeft;
		absPosY += tempElem.offsetTop;
		*/


		// Get the absolute coordinates of the mouse click event
		var e = canvas;
		var AbsX = e.offsetLeft;
		var AbsY = e.offsetTop;
		
		while(e=e.offsetParent)
		{
			AbsX += e.offsetLeft;
			AbsY += e.offsetTop;
	    }
		
		//alert("PX: " + AbsX + "PY" + AbsY);
		//alert("X: " + event.clientX + "Y: " + event.clientY);
		
		// Get the related x and y
		//var cursorX = event.clientX - AbsX;
		//var cursorY = event.clientY - AbsY;
		
		
		//skimmer.left = absPosX;
		//skimmer.top = absPosY;
		skimmer.left = AbsX;
		skimmer.top = AbsY;
		
		if(autoFlag == 1){
		
			simuCursor.set(0,0);
			ind = 0;
			desDir.set(skimmer.agents[ind]);
			reachFlag = 0;
		}
		
	}
	}

	// Select the color mapping schema
	function SelectColor(){
		var selectObj = document.getElementById("selectColor");
		var selectIndex=selectObj.selectedIndex;
		var selectVal = selectObj.options[selectIndex].value;

		skimmer.colorType = selectVal;
		skimmer.updateAgentColor();
	}
	
	
	// Search for the content in the skimmer
	// This is used as the basic interactive mode
	function skimmerSearching() {

		var selectObj = document.getElementById("chooseSource");
		var selectIndex=selectObj.selectedIndex;
		var selectVal = selectObj.options[selectIndex].value;
		
		
		var startSearchingFlag = 1;
		
		// Reset the title record
		titleRecord = "";
		
		// Set the feed URL as well as the title
		switch(selectVal) {
			case 'ncsu_lib_news':
				isFlickr = 0;
				sourceAddress = "http://feeds.feedburner.com/NCSULibrariesNews?format=xml";
				titleRecord = "NCSU Library News";
				break;
			case 'ncsu_events':
				isFlickr = 0;
				sourceAddress = "http://calendar.activedatax.com/ncstate/RSSSyndicator.aspx?category=&location=&type=N&binary=Y&keywords=";
				titleRecord = "NCSU Events";
				break;
			case 'ncsu_twitter_search':
				isFlickr = 0;
				sourceAddress = "http://search.twitter.com/search.rss?q=%23ncsu";
				titleRecord = "Twitter #NCSU";
				break;
			case 'ncsu_twitter_account':
				isFlickr = 0;
				sourceAddress = "http://twitter.ncsu.edu/feed.php";
				titleRecord = "Twitter @NCSU";
				break;	
			case 'ncsu_facebook':
				isFlickr = 0;
				sourceAddress = "http://www.facebook.com/feeds/page.php?format=rss20&id=5983837179";
				titleRecord = "NCSU Facebook";
				break;
			case "google_news":
				isFlickr = 0;
				sourceAddress = "http://news.google.com/news?hl=en&gl=us&q=ncsu&num=100&um=1&ie=UTF-8&output=rss";
				titleRecord = "Google News NCSU";
				break;
			case "flickr_tags":
				isFlickr = 1;
				sourceAddress = "http://api.flickr.com/services/feeds/photos_public.gne?tags=ncsu&lang=en-us&format=rss_200";
				titleRecord = "Flickr NCSU Tag"
				break;
			case "lib_3_m_new":
				isFlickr = 0;
				sourceAddress = "http://catalog.lib.ncsu.edu/?service=search&N=206471&output=rss";
				break;
			case "lib_1_m_new":
				isFlickr = 0;
				sourceAddress = "http://catalog.lib.ncsu.edu/?service=search&N=206470&output=rss";
				break;
			case "lib_1_w_new":
				isFlickr = 0;
				sourceAddress = "http://catalog.lib.ncsu.edu/?service=search&N=206469&output=rss";
				break;
			default:
				startSearchingFlag = 0;
				break;
		}
		
		
		if (startSearchingFlag == 1) {
			//------------------------------------------- Get the content from the Google Feed Api ----------------------------------------
			
			// Reset the feeding flag
			feedFinished = 0;
			
			// Set the URL for the google feed API
			var feed = new google.feeds.Feed(sourceAddress);
			// Set the number of entries to be read from the RSS online
			//feed.setNumEntries(numEntries);
			feed.setNumEntries(100);

			// downloads the feed specified in the constructor from Google's servers and calls the given callback when the download completes
			feed.load(function(result) {
				if (!result.error) {
					feedResult = result;

					numEntries = feedResult.feed.entries.length;
					if (numEntries > 0) {
						skimmer.UpdateSkimmer(feedResult, numEntries);
						
						// Set the title of the feed data
						if (titleRecord != "") {
							skimmer.agentTitle.text = titleRecord;
						}
						
						skimmer.addNewArticles();
						skimmer.extractArticleMinMax();
						skimmer.checkForAdjacencies();
						skimmer.updateAgents();
						skimmer.extractAgentMinMax();
						buildAgentLinkList();
						
						var selectObj = document.getElementById("selectColor");
						var selectIndex=selectObj.selectedIndex;
						var selectVal = selectObj.options[selectIndex].value;

						skimmer.colorType = selectVal;
						skimmer.updateAgentColor();
					}
					else {
						alert("More searching results are needed for visualization.");
					}
				}
				
				feedFinished = 1;

			});

			google.setOnLoadCallback(initialize);
					
		}
	
	}
	
	
	
	
	//------------------------------- Advanced Searching --------------------------------
	
	
	// Search for the content in the skimmer
	function AdvancedSearching() {

		// Choose the searching engine from the list
		//var selectObj = document.getElementById("chooseEngine");
		var selectObj = document.getElementById("chooseSource");
		var selectIndex=selectObj.selectedIndex;
		var selectVal = selectObj.options[selectIndex].value;

		// Choose the search keyword of the advanced searching mode
		var inputObj = document.getElementById("searchContent");
		var inputVal = inputObj.value;

		switch(selectVal) {
			case 'Advanced_twitter_keyword_search':
				isFlickr = 0;
				sourceAddress = "http://search.twitter.com/search.rss?q=" + inputVal;
				break;
			case 'Advanced_twitter_hash_search':
				isFlickr = 0;
				sourceAddress = "http://search.twitter.com/search.rss?q=%23" + inputVal;
				break;
			case "Advanced_google_news":
				isFlickr = 0;
				sourceAddress = "http://news.google.com/news?hl=en&gl=us&q=" + inputVal + "&num=100&um=1&ie=UTF-8&output=rss";
				break;
			case "Advanced_flickr_tags":
				isFlickr = 1;
				sourceAddress = "http://api.flickr.com/services/feeds/photos_public.gne?tags=" + inputVal + "&lang=en-us&format=rss_200";
				break;
			case "Advanced_lib_search":
				isFlickr = 0;
				sourceAddress = "http://catalog.lib.ncsu.edu/?Nty=1&Ntk=Keyword&service=search&N=0&output=rss&Ntt=" + inputVal;
				break;
			default:
				break;
		}
	
	
		//------------------------------------------- Get the content from the Google Feed Api ----------------------------------------
		
		// Reset the feeding flag
		feedFinished = 0;
		
		// Set the URL for the google feed API
		var feed = new google.feeds.Feed(sourceAddress);
		// Set the number of entries to be read from the RSS online
		//feed.setNumEntries(numEntries);
		feed.setNumEntries(100);

		// downloads the feed specified in the constructor from Google's servers and calls the given callback when the download completes
		feed.load(function(result) {
			if (!result.error) {
				feedResult = result;

				numEntries = feedResult.feed.entries.length;
				if (numEntries > 0) {
					skimmer.UpdateSkimmer(feedResult, numEntries);
					skimmer.addNewArticles();
					skimmer.extractArticleMinMax();
					skimmer.checkForAdjacencies();
					skimmer.updateAgents();
					skimmer.extractAgentMinMax();
					buildAgentLinkList();
					
					var selectObj = document.getElementById("selectColor");
					var selectIndex=selectObj.selectedIndex;
					var selectVal = selectObj.options[selectIndex].value;

					skimmer.colorType = selectVal;
					skimmer.updateAgentColor();
				}
				else {
					alert("More searching results are needed for visualization.");
				}
			}

			feedFinished = 1;

		});

		google.setOnLoadCallback(initialize);
				
		
	}
	
	
	
	
	// The driver of he advanced searching mode
	var advancedFlag = 0;
	/*
	function AdvancedSearchDriver() {
	
		if (advancedFlag == 0) {
			AdvancedSearchBtn = document.getElementById("AdvancedSearchBtn");
			AdvancedSearchBtn.textContent = "Advanced";
		
			basicModeTbl = document.getElementById("advancedMode");
			basicModeTbl.hidden = true;
			
			advancedFlag = 1;
		}
		else {
			AdvancedSearchBtn = document.getElementById("AdvancedSearchBtn");
			AdvancedSearchBtn.textContent = "Basic";
		
			advancedModeTbl = document.getElementById("advancedMode");
			advancedModeTbl.hidden = false;
			
			advancedFlag = 0;
		}
		
	}
	*/
	
	
	//-----------------------------------------------------------------------------------------------------------	
	//---------------------------------------------- Automatical Mode -------------------------------------	
	//-----------------------------------------------------------------------------------------------------------	
	
	
	// variables setting the function intervals
	var autoIntervalID;
	
	var timeInterval = 60000;		// the time interval is set 0 minute 30 seconds
	
	var sourceSelectOrder = 0;
	
	var sourceXmlDoc;
	var sourceNodes;
	
	
	// The function used for the automated mode
	function autoModeFunc()
	{
		// Get the source address from the xml file

		websiteNodes = sourceNodes[sourceSelectOrder].getElementsByTagName("website");
		if (websiteNodes[0] != undefined) {
			website = websiteNodes[0].childNodes[0].nodeValue;
			
			var keywordVal = "";
					
			keywordNodes = sourceNodes[sourceSelectOrder].getElementsByTagName("keyword");
			if (keywordNodes[0] != undefined) {
				keywordVal = keywordNodes[0].childNodes[0].nodeValue;
			}

			
			switch (website) {
				case 'ncsu_twitter':
					isFlickr = 0;
					sourceAddress = "http://search.twitter.com/search.rss?q=" + keywordVal + "%23ncsu";
					break;
				case "google_news":
					isFlickr = 0;
					sourceAddress = "http://news.google.com/news?hl=en&gl=us&q=" + keywordVal + "&num=100&um=1&ie=UTF-8&output=rss";
					break;
				case "flickr":
					isFlickr = 1;
					sourceAddress = "http://api.flickr.com/services/feeds/photos_public.gne?tags=" + keywordVal + "&lang=en-us&format=rss_200";
					break;
			}

		}
		else {
			// Read URL directly from the xml file
			feedNodes = sourceNodes[sourceSelectOrder].getElementsByTagName("feed");
			if (feedNodes[0] != undefined) {
				sourceAddress = feedNodes[0].childNodes[0].nodeValue;
			}
		}

		//sourceAddress = sourceNodes[sourceSelectOrder].childNodes[0].nodeValue;
	
	
	
	
		//------------------------------------------- Get the content from the Google Feed Api ----------------------------------------

		// Reset the feeding flag
		feedFinished = 0;
		
		// Set the URL for the google feed API
		var feed = new google.feeds.Feed(sourceAddress);
		// Set the number of entries to be read from the RSS online
		feed.setNumEntries(100);

		// downloads the feed specified in the constructor from Google's servers and calls the given callback when the download completes
		feed.load(function(result) {
			if (!result.error) {
				feedResult = result;
				numEntries = feedResult.feed.entries.length;
				
				if (numEntries > 0) {
					skimmer.UpdateSkimmer(feedResult, numEntries);
					skimmer.addNewArticles();
					skimmer.extractArticleMinMax();
					skimmer.checkForAdjacencies();
					skimmer.updateAgents();
					skimmer.extractAgentMinMax();
					buildAgentLinkList();
					
					simuCursor.set(0,0);
					reachFlag = 0;
		
					ind = 0;
			desDir.set(skimmer.agents[ind]);
					
				

					colorscheme = 0;
					colorNodes = sourceNodes[sourceSelectOrder].getElementsByTagName("color");
					if (colorNodes[0] != undefined) {
						colortag = colorNodes[0].childNodes[0].nodeValue;
						
						switch (colortag) {
							case 'random':
								colorscheme = 0;
								break;
							case 'grammar':
								colorscheme = 1;
								break;
							case 'emotion':
								colorscheme = 3;
								break;
							case 'gray':
								colorscheme = 4;
								break;
							default: 
								colorscheme = 0;
								break;
						}

					}

					// Set the color scheme for skimmer
					skimmer.colorType = colorscheme;
					skimmer.updateAgentColor();
					
					// Set the text in the selecting box
					var selectObj = document.getElementById("selectColor");
					selectObj.selectedIndex = colorscheme;


					timeNodes = sourceNodes[sourceSelectOrder].getElementsByTagName("interval");
					if (timeNodes[0] != undefined) {
						timeoutIntervalXML = timeNodes[0].childNodes[0].nodeValue;

						// Set the minimum time interval 15 seconds so that the time needed to read data is not likely to have effect on the time control
						if (timeoutIntervalXML < 15) {
							timeoutIntervalXML = 15;
						}
						if (timeoutIntervalXML > 900) {
							timeoutIntervalXML = 900;
						}
						

						//alert(timeoutIntervalXML);
						autoIntervalID = setTimeout(autoModeFunc, timeoutIntervalXML * 1000);

						//alert(timeoutIntervalXML);
					}
					else {
						autoIntervalID = setTimeout(autoModeFunc, timeInterval);

						//alert("Default");
					}
					
				}
				else {
					alert("More searching results are needed for visualization.");
				}
			}

			feedFinished = 1;
			
			// circulate the source address
			if (sourceSelectOrder >= sourceNodes.length - 1) {
				sourceSelectOrder = 0
			}
			else {
				sourceSelectOrder = sourceSelectOrder + 1;
			}



		});

		google.setOnLoadCallback(initialize);
	}
	
	// Start or end the auto mode in skimmer
	function autoModeDriver()
	{
		if (autoFlag == 0) {
			// Reading xml file from disk
			sourceXmlDoc = loadXmlFile("data/sourceconfig.xml");
			sourceNodes = sourceXmlDoc.getElementsByTagName("source");

			autoIntervalID = setTimeout(autoModeFunc, 30000);
			//autoIntervalID = setInterval(autoModeFunc, timeInterval);
			autoFlag = 1;

			//autoMode = document.getElementById("autoMode");
			//autoMode.textContent = "Manual";

			// Hide the basic manual mode
			/*
			AdvancedSearchBtn = document.getElementById("AdvancedSearchBtn");
			AdvancedSearchBtn.textContent = "Advanced";
			*/

			basicModeTbl = document.getElementById("basicMode");
			basicModeTbl.hidden = true;
			
			basicModeTbl = document.getElementById("advancedMode");
			basicModeTbl.hidden = true;
			
			advancedFlag = 1;

			var advanceRadioBtn = document.getElementsByName("advanceRadioBtn");
			advanceRadioBtn[0].checked = false;
			advanceRadioBtn[1].checked = true;

		}
		else{
			clearTimeout(autoIntervalID);
			autoFlag = 0;

			//autoMode = document.getElementById("autoMode");
			//autoMode.textContent = "AutoMode";

			// Show the basic manual mode
			basicModeTbl = document.getElementById("basicMode");
			basicModeTbl.hidden = false;

		}
	}
	

	// Set the event function for the boxes
	// A flag is used to decide whether it is the first time the selection box is clicked
	var firstClickFlag = 0;

	function resetSourceSelect() {
		if (firstClickFlag == 0) {
			var selectObj = document.getElementById("chooseSource");
			selectObj.selectedIndex = -1;
			firstClickFlag = 1;
		} else if (firstClickFlag == 2) {
			firstClickFlag = 0;
		}
	}

	function onChangeSourceSelect() {
		skimmerSearching();
		// Set the firstClickFlag 2 because there are now two clicks
		firstClickFlag = 2;
	}	
	

	
	// Radio button for advanced searching mode
	function clickAdvancedRadioBtn() {
		var advanceRadioBtn = document.getElementsByName("advanceRadioBtn");
		if (advanceRadioBtn[1].checked == true) {
			// Hide the advanced control panel
			var advancedModeTbl = document.getElementById("advancedMode");
			advancedModeTbl.hidden = true;
			
			// Hide the advanced options in the selection box
			var selectObj = document.getElementsByName("chooseSource");
			selectObj[0].lastElementChild.hidden = true;
			
			advancedFlag = 1;
		}
		else {
			// Show the advanced control panel
			var advancedModeTbl = document.getElementById("advancedMode");
			advancedModeTbl.hidden = false;
			
			// Show the advanced options in the selection box
			var selectObj = document.getElementsByName("chooseSource");
			selectObj[0].lastElementChild.hidden = false;

			advancedFlag = 0;
		}
	}



	// Radio button for auotomated mode
	function clickAutomatedRadioBtn() {
		var advanceRadioBtn = document.getElementsByName("automatedRadioBtn");
		if (advanceRadioBtn[0].checked == true) {
			// The automated mode
			autoFlag = 0;
			reachFlag = 0;
			ind = 0;
			desDir.set(skimmer.agents[ind]);
			
			
			autoModeDriver();
		}
		else {
			// The manual mode
			autoFlag = 1;

			//console.log(mainDir);
			autoModeDriver();
		}
	}

	
	
</script>

</head>
<body onload = "init();" style="overflow:hidden" onkeydown="globalKeyFunc()" onmousedown="mouseClick(event);" onmousemove="mouseMove(event);" onmouseup="mouseUp(event)"; onresize="resizeWindow()" bgcolor="black">
<table id = "overallFrame" border = "0" cellpadding = "0" cellspacing = "0" bgcolor="black">
	<tr>
		<td>
			<div>
				<table id = "selectFrame" border = "0" cellpadding = "0" style="table-layout:fixed">
					<tr>
						<td>
						
							<table id = "basicMode" border = "0" cellpadding = "0"">

								<!-- Basic manual mode-->
								<tr>
									<td>
										<font color = "white" face = "Arial">Color</font>
									</td>
								</tr>
								<tr>
									<td>
										<select id="selectColor" onChange = SelectColor()>
											<option value = 0>Random</option>
											<option value = 1>Grammar</option>
											<option value = 3>Emotion</option>
											<option value = 4>No Color</option>
										</select>
									</td>
								</tr>
								<tr>
									<td>
										<br/>
									</td>
								</tr>
								<tr>
									<td>
										<font color = "white" face = "Arial">Source</font>
									</td>
								</tr>
								<!-- This selection box select the source of the data from a given list of xml feeds -->
								<tr>
									<td>
										<select id="chooseSource" name="chooseSource" onclick="resetSourceSelect()" onchange="onChangeSourceSelect()">

											<optgroup label="Basic">
												<!-- Basic mode source options -->
												<option value = "ncsu_events">NCSU Events</option>
												<option value = "ncsu_lib_news">NCSU Library News</option>
												<option value = "ncsu_twitter_search">Twitter #NCSU</option>
												<option value = "ncsu_twitter_account">Twitter @NCSU</option>
												<option value = "ncsu_facebook">NCSU Facebook</option>
												<option value = "google_news">Google News NCSU</option>
												<option value = "flickr_tags">Flickr NCSU Tag</option>
												<option value = "lib_3_m_new">Library New in Last 3 Months</option>
												<option value = "lib_1_m_new">Library New in Last Month</option>
												<option value = "lib_1_w_new">Library New in Last Week</option>
											</optgroup>

											<optgroup id="selectOptGroupAdvanced" name="selectOptGroupAdvanced" label="Advanced">
												<!-- Advanced searching source options-->
												<option value = "Advanced_twitter_keyword_search">Twitter Keyword Search</option>
												<option value = "Advanced_twitter_hash_search">Twitter Hash Search</option>
												<option value = "Advanced_google_news">Google News Search</option>
												<option value = "Advanced_flickr_tags">Flickr Image Search</option>
												<option value = "Advanced_lib_search">NCSU Library Search</option>
											</optgroup>

										</select>
									</td>
								</tr>
								<tr>
									<td>
										<br/>
									</td>
								</tr>
								
								<!-- The picture radio button is removed because the slider bar have the same functionality -->
								<!--
								<tr>
									<td>
										<font color = "white" face = "Arial">Picture</font>
									</td>
								</tr>
								<tr>
									<td>
										<input type="radio" id="radio1" name="showImage" value="1" checked="true"> <font color = "white" face = "Arial">Yes</font>
										<input type="radio" id="radio2" name="showImage" value="2"> <font color = "white" face = "Arial">No</font>
									</td>
								</tr>
								-->
								
								<tr>
									<td>
										<font color = "white" face = "Arial">Advanced</font>
									</td>
								</tr>
								<tr>
									<td>
										<input type="radio" id="radio1" name="advanceRadioBtn" value="1" onclick="clickAdvancedRadioBtn()"> <font color = "white" face = "Arial">Yes</font>
										<input type="radio" id="radio2" name="advanceRadioBtn" value="2" checked="true" onclick="clickAdvancedRadioBtn()"> <font color = "white" face = "Arial">No</font>
									</td>
								</tr>

								
								<!-- The searching button is removed for simplicity of interaction -->
								<!--
								<tr>
									<td>
										<button type = "button" name = "skimmerSearching" id = "skimmerSearching" onclick = skimmerSearching()>Search</button>
									</td>
								</tr>
								-->
								<!--
								<tr>
									<td>
										<button type = "button" name = "AdvancedSearchBtn" id = "AdvancedSearchBtn" onclick = AdvancedSearchDriver()>Advanced</button>
									</td>
								</tr>	
								-->
							</table>
						
						</td>

					</tr>


					<tr>
						<td>
							<table id = "advancedMode" border = "0" cellpadding = "0">
					
								<!-- These are used as the Advanced interactive mode -->
								<!--
								<tr>
									<td>
										<font color = "white" face = "Arial">Search Engine</font>
									</td>
								</tr>
								-->
								<!-- This selection box select the source of the search engines from a given list of xml feeds -->
								<!--
								<tr>
									<td>
										<select id="chooseEngine" name="chooseEngine">
											<option value = "ncsu_twitter_search">twitter search</option>
											<option value = "google_news">Google News</option>
											<option value = "flickr_tags">Flickr Images</option>
											<option value = "lib_search">Library Search</option>
										</select>
									</td>
								</tr>
								-->
								<tr>
									<td>
										<br/>
									</td>
								</tr>
								<tr>
									<td>
										<font color = "white" face = "Arial">Keyword</font>
									</td>
								</tr>
								<tr>
									<td>
										<input type = "text" id = "searchContent" name = "searchContent" onkeydown="keyDown(event);" />
									</td>
								</tr>
								<tr>
									<td>
										<br/>
									</td>
								</tr>


								<tr>
									<td>
										<table width="80%">
											<tr>
												<td width="50%" align="left">
													<font color = "white" face = "Arial">Image</font>
												</td>
												<td width="50%" align="right">
													<font color = "white" face = "Arial">Text</font>
												</td>
											</tr>
										</table>
									</td>
								</tr>
								<tr>
									<td>
										<canvas id = "slidercanvas" onmouseup = "SliderMouseUp(event);" onmousedown = "SliderMouseDown(event);" onmousemove = "SliderMouseMove(event);"></canvas>
									</td>
								</tr>
								
								<!-- The advanced searching button is replaced by keyboard event -->
								<!--
								<tr>
									<td>
										<button type = "button" name = "advancedSearching" id = "advancedSearching" onclick = "AdvancedSearching();">AdvancedSearch</button>
									</td>
								</tr>
								-->
								
							</table>
						</td>
					</tr>


					<!-- The button is now replaced by radio button-->
					<!--
					<tr>
						<td>
							<button type = "button" name = "autoMode" id = "autoMode" onclick = "autoModeDriver();">AutoMode</button>
						</td>
					</tr>
					-->


				</table>
			</div>
			<style>
				.footer{
				    width:auto;
				    height:auto;
				    position:absolute;
				    bottom:0px;
				}
			</style>
			<div class="footer">
				<table id = "autoSubFrame" border = "0" cellpadding = "0">
					<!-- This button is used for switching between the manual mode and the automated mode -->
					<tr>
						<td>
							<font color = "white" face = "Arial">Automated</font>
						</td>
					</tr>
					<tr>
						<td>
							<input type="radio" id="radio1" name="automatedRadioBtn" value="1" onclick="clickAutomatedRadioBtn()"> <font color = "white" face = "Arial">Yes</font>
							<input type="radio" id="radio2" name="automatedRadioBtn" value="2" checked="true" onclick="clickAutomatedRadioBtn()"> <font color = "white" face = "Arial">No</font>
						</td>
					</tr>

				</table>
			</div>
		</td>

		<td>
			<canvas id = "canvas"></canvas>
		</td>
		
	</tr>
</table>

<script type="text/javascript">

	var selectObj = document.getElementById("chooseSource");
	selectObj.selectedIndex = 0;

	// Initially set basic manual mode
	//AdvancedSearchDriver();
	clickAdvancedRadioBtn();
	// Initially set automated mode
	//autoModeDriver();
	var automatedRadioBtn = document.getElementsByName("automatedRadioBtn");
	automatedRadioBtn[0].checked = false;
	automatedRadioBtn[1].checked = true;

	

	// Set the time interval for mouse move checking
	var mouseMoveCheckingTimeInterval = 1000;

	mouseMoveIntervalID = setInterval(checkMouseMove, mouseMoveCheckingTimeInterval);

	//intervalID = setInterval(draw, 25);
	intervalID = setInterval(drawDriver, 25);

	// Set the time interval for drawing slider bar
	intervalSlider = setInterval(drawSliderBar, 5);
	
	
	// Set the time interval for auto refreshing
	// 10 minutes is set as the refreshing rate
	var autoRefreshingTimeInterval = 600000;
	
	// Set the refresh rate
	setInterval(AddNewData, autoRefreshingTimeInterval);
</script>
</body>
</html>